(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('flatted')) :
	typeof define === 'function' && define.amd ? define(['exports', 'flatted'], factory) :
	(factory((global.AI = {}),global.Flatted));
}(this, (function (exports,flatted) { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var MAKE_MOVE = 'MAKE_MOVE';
var GAME_EVENT = 'GAME_EVENT';
var RESTORE = 'RESTORE';
var RESET = 'RESET';
var UNDO = 'UNDO';
var REDO = 'REDO';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) {
    me.s0 += 1;
  }
  me.s1 -= mash(seed);
  if (me.s1 < 0) {
    me.s1 += 1;
  }
  me.s2 -= mash(seed);
  if (me.s2 < 0) {
    me.s2 += 1;
  }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;
  if (state) {
    if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) == 'object') copy(state, xg);
    prng.state = function () {
      return copy(xg, {});
    };
  }
  return prng;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */
var Random = function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(ctx) {
    classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = ctx._random || { seed: '0' };
  }

  /**
   * Updates ctx with the PRNG state.
   * @param {object} ctx - The ctx object to update.
   */


  createClass(Random, [{
    key: 'update',
    value: function update(ctx) {
      return _extends({}, ctx, { _random: this.state });
    }

    /**
     * Attaches the Random API to ctx.
     * @param {object} ctx - The ctx object to attach to.
     */

  }, {
    key: 'attach',
    value: function attach(ctx) {
      return _extends({}, ctx, { random: this._api() });
    }

    /**
     * Generate a random number.
     */

  }, {
    key: '_random',
    value: function _random() {
      var R = this.state;

      var fn = void 0;
      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, { state: true });
      } else {
        fn = new alea('', { state: R.prngstate });
      }

      var number = fn();

      this.state = _extends({}, R, {
        prngstate: fn.state()
      });

      return number;
    }
  }, {
    key: '_api',
    value: function _api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      };

      // Generate functions for predefined dice values D4 - D20.
      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];
        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _extends({}, predefined, {

        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        }
      });
    }
  }]);
  return Random;
}();

/**
 * Removes the attached Random api from ctx.
 *
 * @param {object} ctx - The ctx object with the Random API attached.
 * @returns {object} A plain ctx object without the Random API.
 */
Random.detach = function (ctx) {
  var random = ctx.random,
      rest = objectWithoutProperties(ctx, ['random']); // eslint-disable-line no-unused-vars

  return rest;
};

/**
 * Generates a new seed from the current date / time.
 */
Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var makeMove = function makeMove(type, args, playerID, credentials) {
  return {
    type: MAKE_MOVE,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var gameEvent = function gameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials },
    automatic: true
  };
};

/**
 * Used to reset the Redux store's state.
 * @param {object} state - The state to restore.
 */


/**
 * Used to reset the game state.
 */


/**
 * Used to undo the last move.
 */


/**
 * Used to redo the last undone move.
 */

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Events
 */
var Events = function () {
  function Events(flow, playerID) {
    classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }

  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  createClass(Events, [{
    key: 'attach',
    value: function attach(ctx) {
      var _this = this;

      var events = {};

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({ key: key, args: args });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _extends({}, ctx, { events: events });
    }

    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: 'update',
    value: function update(state) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.dispatch[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var action = automaticGameEvent(item.key, item.args, this.playerID);
          state = _extends({}, state, this.flow.processGameEvent(state, action));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return state;
    }
  }]);
  return Events;
}();

/**
 * Detaches the Events API from ctx.
 * @param {object} ctx - The ctx object to strip.
 */
Events.detach = function (ctx) {
  var events = ctx.events,
      rest = objectWithoutProperties(ctx, ['events']); // eslint-disable-line no-unused-vars

  return rest;
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 * @param {...object} game - Return value of Game().
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true if we are in a multiplayer client.
 */
function CreateGameReducer(_ref) {
  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      multiplayer = _ref.multiplayer;

  if (!numPlayers) {
    numPlayers = 2;
  }

  var ctx = game.flow.ctx(numPlayers);

  var seed = game.seed;
  if (seed === undefined) {
    seed = Random.seed();
  }
  ctx._random = { seed: seed };

  var random = new Random(ctx);
  var ctxWithAPI = random.attach(ctx);

  var initial = {
    // User managed state.
    G: game.setup(ctxWithAPI),

    // Framework managed state.
    ctx: ctx,

    // A list of actions performed so far. Used by the
    // GameLog to display a journal of moves.
    log: [],

    // List of {G, ctx} pairs that can be undone.
    _undo: [],

    // List of {G, ctx} pairs that can be redone.
    _redo: [],

    // A monotonically non-decreasing ID to ensure that
    // state updates are only allowed from clients that
    // are at the same version that the server.
    _stateID: 0,

    // A snapshot of this object so that actions can be
    // replayed over it to view old snapshots.
    _initial: {}
  };

  var events = new Events(game.flow, ctx.currentPlayer);
  ctxWithAPI = events.attach(ctxWithAPI);

  var state = game.flow.init({ G: initial.G, ctx: ctxWithAPI });

  var _events$update = events.update(state),
      ctxWithEvents = _events$update.ctx;

  initial.G = state.G;
  initial._undo = state._undo;
  initial.ctx = ctxWithEvents;
  initial.ctx = random.update(initial.ctx);
  initial.ctx = Random.detach(initial.ctx);
  initial.ctx = Events.detach(initial.ctx);

  var deepCopy = function deepCopy(obj) {
    return flatted.parse(flatted.stringify(obj));
  };
  initial._initial = deepCopy(initial);

  /**
   * GameReducer
   *
   * Redux reducer that maintains the overall game state.
   * @param {object} state - The state before the action.
   * @param {object} action - A Redux action.
   */
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initial;
    var action = arguments[1];

    switch (action.type) {
      case GAME_EVENT:
        {
          // Process game events only on the server.
          // These events like `endTurn` typically
          // contain code that may rely on secret state
          // and cannot be computed on the client.
          if (multiplayer) {
            return state;
          }

          // Ignore the event if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerCallEvent(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random = new Random(state.ctx);
          // Initialize Events API.
          var _events = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          state = _extends({}, state, { ctx: _random.attach(state.ctx) });
          // Attach Events API to ctx.
          state = _extends({}, state, { ctx: _events.attach(state.ctx) });

          // Update state.
          var newState = game.flow.processGameEvent(state, action);
          // Trigger any events that were called via the Events API.
          newState = _events.update(newState);
          // Update ctx with PRNG state.
          var _ctx = _random.update(newState.ctx);
          // Detach Random API from ctx.
          _ctx = Random.detach(_ctx);
          // Detach Events API from ctx.
          _ctx = Events.detach(_ctx);

          return _extends({}, newState, { ctx: _ctx, _stateID: state._stateID + 1 });
        }

      case MAKE_MOVE:
        {
          // Check whether the game knows the move at all.
          if (!game.moveNames.includes(action.payload.type)) {
            return state;
          }

          // Ignore the move if it isn't allowed at this point.
          if (!game.flow.canMakeMove(state.G, state.ctx, action.payload.type)) {
            return state;
          }

          // Ignore the move if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerMakeMove(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random2 = new Random(state.ctx);
          // Initialize Events API.
          var _events2 = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          var _ctxWithAPI = _random2.attach(state.ctx);
          // Attach Events API to ctx.
          _ctxWithAPI = _events2.attach(_ctxWithAPI);

          // Process the move.
          var G = game.processMove(state.G, action.payload, _ctxWithAPI);
          if (G === undefined) {
            // the game declared the move as invalid.
            return state;
          }

          // Update ctx with PRNG state.
          var _ctx2 = _random2.update(state.ctx);
          // Detach Random API from ctx.
          _ctx2 = Random.detach(_ctx2);
          // Detach Events API from ctx.
          _ctx2 = Events.detach(_ctx2);

          // Undo changes to G if the move should not run on the client.
          if (multiplayer && !game.flow.optimisticUpdate(G, _ctx2, action.payload)) {
            G = state.G;
          }

          var log = [].concat(toConsumableArray(state.log), [action]);
          state = _extends({}, state, { G: G, ctx: _ctx2, log: log, _stateID: state._stateID + 1 });

          // If we're on the client, just process the move
          // and no triggers in multiplayer mode.
          // These will be processed on the server, which
          // will send back a state update.
          if (multiplayer) {
            return state;
          }

          // Allow the flow reducer to process any triggers that happen after moves.
          state = _extends({}, state, { ctx: _random2.attach(state.ctx) });
          state = _extends({}, state, { ctx: _events2.attach(state.ctx) });
          state = game.flow.processMove(state, action.payload);
          state = _events2.update(state);
          state = _extends({}, state, { ctx: _random2.update(state.ctx) });
          state = _extends({}, state, { ctx: Random.detach(state.ctx) });
          state = _extends({}, state, { ctx: Events.detach(state.ctx) });

          return state;
        }

      case RESTORE:
        {
          return action.state;
        }

      case RESET:
        {
          return initial;
        }

      case UNDO:
        {
          var _state = state,
              _undo = _state._undo,
              _redo = _state._redo;


          if (_undo.length < 2) {
            return state;
          }

          var last = _undo[_undo.length - 1];
          var restore = _undo[_undo.length - 2];

          // Only allow undoable moves to be undone.
          if (!game.flow.canUndoMove(state.G, state.ctx, last.moveType)) {
            return state;
          }

          return _extends({}, state, {
            G: restore.G,
            ctx: restore.ctx,
            _undo: _undo.slice(0, _undo.length - 1),
            _redo: [last].concat(toConsumableArray(_redo))
          });
        }

      case REDO:
        {
          var _state2 = state,
              _undo2 = _state2._undo,
              _redo2 = _state2._redo;


          if (_redo2.length == 0) {
            return state;
          }

          var first = _redo2[0];

          return _extends({}, state, {
            G: first.G,
            ctx: first.ctx,
            _undo: [].concat(toConsumableArray(_undo2), [first]),
            _redo: _redo2.slice(1)
          });
        }

      default:
        {
          return state;
        }
    }
  };
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Simulates the game till the end or a max depth.
 *
 * @param {...object} game - The game object.
 * @param {...object} bots - An array of bots.
 * @param {...object} state - The game state to start from.
 */


var Bot = function () {
  function Bot(_ref2) {
    var _this = this;

    var enumerate = _ref2.enumerate,
        seed = _ref2.seed;
    classCallCheck(this, Bot);

    this.enumerate = function (G, ctx, playerID) {
      var actions = _this.enumerateFn(G, ctx, playerID);
      return actions.map(function (a) {
        if (a.payload !== undefined) {
          return a;
        }

        if (a.move !== undefined) {
          return makeMove(a.move, a.args, playerID);
        }

        if (a.event !== undefined) {
          return gameEvent(a.event, a.args, playerID);
        }
      });
    };

    this.enumerateFn = enumerate;
    this.seed = seed;
  }

  createClass(Bot, [{
    key: 'random',
    value: function random(arg) {
      var number = void 0;

      if (this.seed !== undefined) {
        var r = null;
        if (this.prngstate) {
          r = new alea('', { state: this.prngstate });
        } else {
          r = new alea(this.seed, { state: true });
        }

        number = r();
        this.prngstate = r.state();
      } else {
        number = Math.random();
      }

      if (arg) {
        if (arg.length) {
          var id = Math.floor(number * arg.length);
          return arg[id];
        } else {
          return Math.floor(number * arg);
        }
      }

      return number;
    }
  }]);
  return Bot;
}();

var RandomBot = function (_Bot) {
  inherits(RandomBot, _Bot);

  function RandomBot() {
    classCallCheck(this, RandomBot);
    return possibleConstructorReturn(this, (RandomBot.__proto__ || Object.getPrototypeOf(RandomBot)).apply(this, arguments));
  }

  createClass(RandomBot, [{
    key: 'play',
    value: function play(_ref3, playerID) {
      var G = _ref3.G,
          ctx = _ref3.ctx;

      var moves = this.enumerate(G, ctx, playerID);
      return { action: this.random(moves) };
    }
  }]);
  return RandomBot;
}(Bot);

var MCTSBot = function (_Bot2) {
  inherits(MCTSBot, _Bot2);

  function MCTSBot(_ref4) {
    var enumerate = _ref4.enumerate,
        seed = _ref4.seed,
        objectives = _ref4.objectives,
        game = _ref4.game,
        iterations = _ref4.iterations,
        playoutDepth = _ref4.playoutDepth;
    classCallCheck(this, MCTSBot);

    var _this3 = possibleConstructorReturn(this, (MCTSBot.__proto__ || Object.getPrototypeOf(MCTSBot)).call(this, { enumerate: enumerate, seed: seed }));

    if (objectives === undefined) {
      objectives = function objectives() {
        return {};
      };
    }

    _this3.objectives = objectives;
    _this3.reducer = CreateGameReducer({ game: game });
    _this3.iterations = iterations || 1000;
    _this3.playoutDepth = playoutDepth || 50;
    return _this3;
  }

  createClass(MCTSBot, [{
    key: 'createNode',
    value: function createNode(_ref5) {
      var state = _ref5.state,
          parentAction = _ref5.parentAction,
          parent = _ref5.parent,
          playerID = _ref5.playerID;
      var G = state.G,
          ctx = state.ctx;


      var actions = [];
      var objectives = [];

      if (playerID !== undefined) {
        actions = this.enumerate(G, ctx, playerID);
        objectives = this.objectives(G, ctx, playerID);
      } else {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = ctx.actionPlayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _playerID = _step.value;

            actions = actions.concat(this.enumerate(G, ctx, _playerID));
            objectives = objectives.concat(this.objectives(G, ctx, _playerID));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return {
        // Game state at this node.
        state: state,
        // Parent of the node.
        parent: parent,
        // Move used to get to this node.
        parentAction: parentAction,
        // Unexplored actions.
        actions: actions,
        // Current objectives.
        objectives: objectives,
        // Children of the node.
        children: [],
        // Number of simulations that pass through this node.
        visits: 0,
        // Number of wins for this node.
        value: 0
      };
    }
  }, {
    key: 'select',
    value: function select(node) {
      // This node has unvisited children.
      if (node.actions.length > 0) {
        return node;
      }

      // This is a terminal node.
      if (node.children.length == 0) {
        return node;
      }

      var selectedChild = null;
      var best = 0.0;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;

          var childVisits = child.visits + Number.EPSILON;
          var uct = child.value / childVisits + Math.sqrt(2 * Math.log(node.visits) / childVisits);
          if (selectedChild == null || uct > best) {
            best = uct;
            selectedChild = child;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return this.select(selectedChild);
    }
  }, {
    key: 'expand',
    value: function expand(node) {
      var actions = node.actions;

      if (actions.length == 0 || node.state.ctx.gameover !== undefined) {
        return node;
      }

      var id = this.random(actions.length);
      var action = actions[id];
      node.actions.splice(id, 1);
      var childState = this.reducer(node.state, action);
      var childNode = this.createNode({
        state: childState,
        parentAction: action,
        parent: node
      });
      node.children.push(childNode);
      return childNode;
    }
  }, {
    key: 'playout',
    value: function playout(node) {
      var _this4 = this;

      var state = node.state;

      var _loop = function _loop(i) {
        var _state = state,
            G = _state.G,
            ctx = _state.ctx;

        var moves = _this4.enumerate(G, ctx, ctx.actionPlayers[0]);

        // Check if any objectives are met.
        var objectives = _this4.objectives(G, ctx);
        var score = Object.keys(objectives).reduce(function (score, key) {
          var objective = objectives[key];
          if (objective.checker(G, ctx)) {
            return score + objective.weight;
          }
          return score;
        }, 0.0);

        // If so, stop and return the score.
        if (score > 0) {
          return {
            v: { score: score }
          };
        }

        if (!moves || moves.length == 0) {
          return {
            v: undefined
          };
        }

        var id = _this4.random(moves.length);
        var childState = _this4.reducer(state, moves[id]);
        state = childState;
      };

      for (var i = 0; i < this.playoutDepth && state.ctx.gameover === undefined; i++) {
        var _ret = _loop(i);

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }

      return state.ctx.gameover;
    }
  }, {
    key: 'backpropagate',
    value: function backpropagate(node) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      node.visits++;

      if (result.score !== undefined) {
        node.value += result.score;
      }

      if (result.draw === true) {
        node.value += 0.5;
      }

      if (node.parentAction && result.winner === node.parentAction.payload.playerID) {
        node.value++;
      }

      if (node.parent) {
        this.backpropagate(node.parent, result);
      }
    }
  }, {
    key: 'play',
    value: function play(state, playerID) {
      var root = this.createNode({ state: state, playerID: playerID });

      for (var i = 0; i < this.iterations; i++) {
        var leaf = this.select(root);
        var child = this.expand(leaf);
        var result = this.playout(child);
        this.backpropagate(child, result);
      }

      var selectedChild = null;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = root.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _child = _step3.value;

          if (selectedChild == null || _child.visits > selectedChild.visits) {
            selectedChild = _child;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var action = selectedChild && selectedChild.parentAction;
      var metadata = root;

      return { action: action, metadata: metadata };
    }
  }]);
  return MCTSBot;
}(Bot);

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

function AI(_ref) {
  var bot = _ref.bot,
      enumerate = _ref.enumerate,
      visualize = _ref.visualize;

  if (!bot) {
    bot = MCTSBot;
  }

  return { bot: bot, enumerate: enumerate, visualize: visualize };
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

exports.AI = AI;
exports.RandomBot = RandomBot;
exports.MCTSBot = MCTSBot;

Object.defineProperty(exports, '__esModule', { value: true });

})));
