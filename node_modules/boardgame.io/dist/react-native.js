(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('redux'), require('socket.io-client'), require('flatted')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'redux', 'socket.io-client', 'flatted'], factory) :
	(factory((global.ReactNativeClient = {}),global.React,global.PropTypes,global.Redux,global.io,global.Flatted));
}(this, (function (exports,React,PropTypes,redux,io,flatted) { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

React = React && React.hasOwnProperty('default') ? React['default'] : React;
PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
io = io && io.hasOwnProperty('default') ? io['default'] : io;

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var MAKE_MOVE = 'MAKE_MOVE';
var GAME_EVENT = 'GAME_EVENT';
var RESTORE = 'RESTORE';
var RESET = 'RESET';
var UNDO = 'UNDO';
var REDO = 'REDO';

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var makeMove = function makeMove(type, args, playerID, credentials) {
  return {
    type: MAKE_MOVE,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var gameEvent = function gameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials },
    automatic: true
  };
};

/**
 * Used to reset the Redux store's state.
 * @param {object} state - The state to restore.
 */
var restore = function restore(state) {
  return {
    type: RESTORE,
    state: state
  };
};

/**
 * Used to reset the game state.
 */
var reset = function reset() {
  return {
    type: RESET
  };
};

/**
 * Used to undo the last move.
 */
var undo = function undo() {
  return {
    type: UNDO
  };
};

/**
 * Used to redo the last undone move.
 */
var redo = function redo() {
  return {
    type: REDO
  };
};

var ActionCreators = Object.freeze({
	makeMove: makeMove,
	gameEvent: gameEvent,
	automaticGameEvent: automaticGameEvent,
	restore: restore,
	reset: reset,
	undo: undo,
	redo: redo
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

// The actions that are sent across the network.
var blacklistedActions = new Set([RESTORE]);

/**
 * Multiplayer
 *
 * Handles all the multiplayer interactions on the client-side.
 */
var Multiplayer = function () {
  /**
   * Creates a new Mutiplayer instance.
   * @param {object} socket - Override for unit tests.
   * @param {object} socketOpts - Options to pass to socket.io.
   * @param {string} gameID - The game ID to connect to.
   * @param {string} playerID - The player ID associated with this client.
   * @param {string} gameName - The game type (the `name` field in `Game`).
   * @param {string} numPlayers - The number of players.
   * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.
   */
  function Multiplayer() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        socket = _ref.socket,
        socketOpts = _ref.socketOpts,
        gameID = _ref.gameID,
        playerID = _ref.playerID,
        gameName = _ref.gameName,
        numPlayers = _ref.numPlayers,
        server = _ref.server;

    classCallCheck(this, Multiplayer);

    this.server = server;
    this.socket = socket;
    this.socketOpts = socketOpts;
    this.gameName = gameName || 'default';
    this.gameID = gameID || 'default';
    this.playerID = playerID || null;
    this.numPlayers = numPlayers || 2;
    this.gameID = this.gameName + ':' + this.gameID;
    this.isConnected = false;
    this.callback = function () {};
  }

  /**
   * Creates a Redux store with some middleware that sends actions
   * to the server whenever they are dispatched.
   * @param {function} reducer - The game reducer.
   * @param {function} enhancer - optional enhancer to apply to Redux store
   */


  createClass(Multiplayer, [{
    key: 'createStore',
    value: function createStore$$1(reducer, enhancer) {
      var _this = this;

      this.store = null;

      // Redux middleware to emit a message on a socket
      // whenever an action is dispatched.
      var SocketEnhancer = redux.applyMiddleware(function (_ref2) {
        var getState = _ref2.getState;
        return function (next) {
          return function (action) {
            var state = getState();
            var result = next(action);

            if (!blacklistedActions.has(action.type) && action._remote != true) {
              _this.socket.emit('action', action, state._stateID, _this.gameID, _this.playerID);
            }

            return result;
          };
        };
      });

      enhancer = enhancer ? redux.compose(enhancer, SocketEnhancer) : SocketEnhancer;
      this.store = redux.createStore(reducer, enhancer);

      return this.store;
    }

    /**
     * Connect to the server.
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (!this.socket) {
        if (this.server) {
          var server = this.server;
          if (server.search(/^https?:\/\//) == -1) {
            server = 'http://' + this.server;
          }

          this.socket = io(server + '/' + this.gameName, this.socketOpts);
        } else {
          this.socket = io('/' + this.gameName, this.socketOpts);
        }
      }

      this.socket.on('sync', function (gameID, state) {
        if (gameID == _this2.gameID && state._stateID >= _this2.store.getState()._stateID) {
          var action = restore(state);
          action._remote = true;
          _this2.store.dispatch(action);
        }
      });

      // Initial sync to get game state.
      this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);

      // Keep track of connection status.
      this.socket.on('connect', function () {
        _this2.isConnected = true;
        _this2.callback();
      });
      this.socket.on('disconnect', function () {
        _this2.isConnected = false;
        _this2.callback();
      });
    }

    /**
     * Subscribe to connection state changes.
     */

  }, {
    key: 'subscribe',
    value: function subscribe(fn) {
      this.callback = fn;
    }

    /**
     * Updates the game id.
     * @param {string} id - The new game id.
     */

  }, {
    key: 'updateGameID',
    value: function updateGameID(id) {
      this.gameID = this.gameName + ':' + id;

      var action = reset();
      action._remote = true;
      this.store.dispatch(action);

      if (this.socket) {
        this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);
      }
    }

    /**
     * Updates the player associated with this client.
     * @param {string} id - The new player id.
     */

  }, {
    key: 'updatePlayerID',
    value: function updatePlayerID(id) {
      this.playerID = id;

      var action = reset();
      action._remote = true;
      this.store.dispatch(action);

      if (this.socket) {
        this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);
      }
    }
  }]);
  return Multiplayer;
}();

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) {
    me.s0 += 1;
  }
  me.s1 -= mash(seed);
  if (me.s1 < 0) {
    me.s1 += 1;
  }
  me.s2 -= mash(seed);
  if (me.s2 < 0) {
    me.s2 += 1;
  }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;
  if (state) {
    if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) == 'object') copy(state, xg);
    prng.state = function () {
      return copy(xg, {});
    };
  }
  return prng;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */
var Random = function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(ctx) {
    classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = ctx._random || { seed: '0' };
  }

  /**
   * Updates ctx with the PRNG state.
   * @param {object} ctx - The ctx object to update.
   */


  createClass(Random, [{
    key: 'update',
    value: function update(ctx) {
      return _extends({}, ctx, { _random: this.state });
    }

    /**
     * Attaches the Random API to ctx.
     * @param {object} ctx - The ctx object to attach to.
     */

  }, {
    key: 'attach',
    value: function attach(ctx) {
      return _extends({}, ctx, { random: this._api() });
    }

    /**
     * Generate a random number.
     */

  }, {
    key: '_random',
    value: function _random() {
      var R = this.state;

      var fn = void 0;
      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, { state: true });
      } else {
        fn = new alea('', { state: R.prngstate });
      }

      var number = fn();

      this.state = _extends({}, R, {
        prngstate: fn.state()
      });

      return number;
    }
  }, {
    key: '_api',
    value: function _api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      };

      // Generate functions for predefined dice values D4 - D20.
      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];
        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _extends({}, predefined, {

        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        }
      });
    }
  }]);
  return Random;
}();

/**
 * Removes the attached Random api from ctx.
 *
 * @param {object} ctx - The ctx object with the Random API attached.
 * @returns {object} A plain ctx object without the Random API.
 */
Random.detach = function (ctx) {
  var random = ctx.random,
      rest = objectWithoutProperties(ctx, ['random']); // eslint-disable-line no-unused-vars

  return rest;
};

/**
 * Generates a new seed from the current date / time.
 */
Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Events
 */
var Events = function () {
  function Events(flow, playerID) {
    classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }

  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  createClass(Events, [{
    key: 'attach',
    value: function attach(ctx) {
      var _this = this;

      var events = {};

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({ key: key, args: args });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _extends({}, ctx, { events: events });
    }

    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: 'update',
    value: function update(state) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.dispatch[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var action = automaticGameEvent(item.key, item.args, this.playerID);
          state = _extends({}, state, this.flow.processGameEvent(state, action));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return state;
    }
  }]);
  return Events;
}();

/**
 * Detaches the Events API from ctx.
 * @param {object} ctx - The ctx object to strip.
 */
Events.detach = function (ctx) {
  var events = ctx.events,
      rest = objectWithoutProperties(ctx, ['events']); // eslint-disable-line no-unused-vars

  return rest;
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 * @param {...object} game - Return value of Game().
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true if we are in a multiplayer client.
 */
function CreateGameReducer(_ref) {
  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      multiplayer = _ref.multiplayer;

  if (!numPlayers) {
    numPlayers = 2;
  }

  var ctx = game.flow.ctx(numPlayers);

  var seed = game.seed;
  if (seed === undefined) {
    seed = Random.seed();
  }
  ctx._random = { seed: seed };

  var random = new Random(ctx);
  var ctxWithAPI = random.attach(ctx);

  var initial = {
    // User managed state.
    G: game.setup(ctxWithAPI),

    // Framework managed state.
    ctx: ctx,

    // A list of actions performed so far. Used by the
    // GameLog to display a journal of moves.
    log: [],

    // List of {G, ctx} pairs that can be undone.
    _undo: [],

    // List of {G, ctx} pairs that can be redone.
    _redo: [],

    // A monotonically non-decreasing ID to ensure that
    // state updates are only allowed from clients that
    // are at the same version that the server.
    _stateID: 0,

    // A snapshot of this object so that actions can be
    // replayed over it to view old snapshots.
    _initial: {}
  };

  var events = new Events(game.flow, ctx.currentPlayer);
  ctxWithAPI = events.attach(ctxWithAPI);

  var state = game.flow.init({ G: initial.G, ctx: ctxWithAPI });

  var _events$update = events.update(state),
      ctxWithEvents = _events$update.ctx;

  initial.G = state.G;
  initial._undo = state._undo;
  initial.ctx = ctxWithEvents;
  initial.ctx = random.update(initial.ctx);
  initial.ctx = Random.detach(initial.ctx);
  initial.ctx = Events.detach(initial.ctx);

  var deepCopy = function deepCopy(obj) {
    return flatted.parse(flatted.stringify(obj));
  };
  initial._initial = deepCopy(initial);

  /**
   * GameReducer
   *
   * Redux reducer that maintains the overall game state.
   * @param {object} state - The state before the action.
   * @param {object} action - A Redux action.
   */
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initial;
    var action = arguments[1];

    switch (action.type) {
      case GAME_EVENT:
        {
          // Process game events only on the server.
          // These events like `endTurn` typically
          // contain code that may rely on secret state
          // and cannot be computed on the client.
          if (multiplayer) {
            return state;
          }

          // Ignore the event if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerCallEvent(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random = new Random(state.ctx);
          // Initialize Events API.
          var _events = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          state = _extends({}, state, { ctx: _random.attach(state.ctx) });
          // Attach Events API to ctx.
          state = _extends({}, state, { ctx: _events.attach(state.ctx) });

          // Update state.
          var newState = game.flow.processGameEvent(state, action);
          // Trigger any events that were called via the Events API.
          newState = _events.update(newState);
          // Update ctx with PRNG state.
          var _ctx = _random.update(newState.ctx);
          // Detach Random API from ctx.
          _ctx = Random.detach(_ctx);
          // Detach Events API from ctx.
          _ctx = Events.detach(_ctx);

          return _extends({}, newState, { ctx: _ctx, _stateID: state._stateID + 1 });
        }

      case MAKE_MOVE:
        {
          // Check whether the game knows the move at all.
          if (!game.moveNames.includes(action.payload.type)) {
            return state;
          }

          // Ignore the move if it isn't allowed at this point.
          if (!game.flow.canMakeMove(state.G, state.ctx, action.payload.type)) {
            return state;
          }

          // Ignore the move if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerMakeMove(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random2 = new Random(state.ctx);
          // Initialize Events API.
          var _events2 = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          var _ctxWithAPI = _random2.attach(state.ctx);
          // Attach Events API to ctx.
          _ctxWithAPI = _events2.attach(_ctxWithAPI);

          // Process the move.
          var G = game.processMove(state.G, action.payload, _ctxWithAPI);
          if (G === undefined) {
            // the game declared the move as invalid.
            return state;
          }

          // Update ctx with PRNG state.
          var _ctx2 = _random2.update(state.ctx);
          // Detach Random API from ctx.
          _ctx2 = Random.detach(_ctx2);
          // Detach Events API from ctx.
          _ctx2 = Events.detach(_ctx2);

          // Undo changes to G if the move should not run on the client.
          if (multiplayer && !game.flow.optimisticUpdate(G, _ctx2, action.payload)) {
            G = state.G;
          }

          var log = [].concat(toConsumableArray(state.log), [action]);
          state = _extends({}, state, { G: G, ctx: _ctx2, log: log, _stateID: state._stateID + 1 });

          // If we're on the client, just process the move
          // and no triggers in multiplayer mode.
          // These will be processed on the server, which
          // will send back a state update.
          if (multiplayer) {
            return state;
          }

          // Allow the flow reducer to process any triggers that happen after moves.
          state = _extends({}, state, { ctx: _random2.attach(state.ctx) });
          state = _extends({}, state, { ctx: _events2.attach(state.ctx) });
          state = game.flow.processMove(state, action.payload);
          state = _events2.update(state);
          state = _extends({}, state, { ctx: _random2.update(state.ctx) });
          state = _extends({}, state, { ctx: Random.detach(state.ctx) });
          state = _extends({}, state, { ctx: Events.detach(state.ctx) });

          return state;
        }

      case RESTORE:
        {
          return action.state;
        }

      case RESET:
        {
          return initial;
        }

      case UNDO:
        {
          var _state = state,
              _undo = _state._undo,
              _redo = _state._redo;


          if (_undo.length < 2) {
            return state;
          }

          var last = _undo[_undo.length - 1];
          var restore = _undo[_undo.length - 2];

          // Only allow undoable moves to be undone.
          if (!game.flow.canUndoMove(state.G, state.ctx, last.moveType)) {
            return state;
          }

          return _extends({}, state, {
            G: restore.G,
            ctx: restore.ctx,
            _undo: _undo.slice(0, _undo.length - 1),
            _redo: [last].concat(toConsumableArray(_redo))
          });
        }

      case REDO:
        {
          var _state2 = state,
              _undo2 = _state2._undo,
              _redo2 = _state2._redo;


          if (_redo2.length == 0) {
            return state;
          }

          var first = _redo2[0];

          return _extends({}, state, {
            G: first.G,
            ctx: first.ctx,
            _undo: [].concat(toConsumableArray(_undo2), [first]),
            _redo: _redo2.slice(1)
          });
        }

      default:
        {
          return state;
        }
    }
  };
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * createDispatchers
 *
 * Create action dispatcher wrappers with bound playerID and credentials
 */
function createDispatchers(storeActionType, innerActionNames, store, playerID, credentials, multiplayer) {
  return innerActionNames.reduce(function (dispatchers, name) {
    dispatchers[name] = function () {
      var assumedPlayerID = playerID;

      // In singleplayer mode, if the client does not have a playerID
      // associated with it, we attach the currentPlayer as playerID.
      if (!multiplayer && (playerID === null || playerID === undefined)) {
        var state = store.getState();
        assumedPlayerID = state.ctx.currentPlayer;
      }

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      store.dispatch(ActionCreators[storeActionType](name, args, assumedPlayerID, credentials));
    };
    return dispatchers;
  }, {});
}

/**
 * createEventDispatchers
 *
 * Creates a set of dispatchers to dispatch game flow events.
 * @param {Array} eventNames - A list of event names.
 * @param {object} store - The Redux store to create dispatchers for.
 * @param {string} playerID - The ID of the player dispatching these events.
 * @param {string} credentials - A key indicating that the player is authorized to play.
 */
var createEventDispatchers = createDispatchers.bind(null, 'gameEvent');

/**
 * createMoveDispatchers
 *
 * Creates a set of dispatchers to make moves.
 * @param {Array} moveNames - A list of move names.
 * @param {object} store - The Redux store to create dispatchers for.
 * @param {string} playerID - The ID of the player dispatching these events.
 * @param {string} credentials - A key indicating that the player is authorized to play.
 */
var createMoveDispatchers = createDispatchers.bind(null, 'makeMove');

/**
 * Implementation of Client (see below).
 */

var _ClientImpl = function () {
  function _ClientImpl(_ref) {
    var _this = this;

    var game = _ref.game,
        ai = _ref.ai,
        numPlayers = _ref.numPlayers,
        multiplayer = _ref.multiplayer,
        socketOpts = _ref.socketOpts,
        gameID = _ref.gameID,
        playerID = _ref.playerID,
        credentials = _ref.credentials,
        enhancer = _ref.enhancer;
    classCallCheck(this, _ClientImpl);

    this.game = game;
    this.playerID = playerID;
    this.gameID = gameID;
    this.credentials = credentials;

    var server = undefined;
    if (multiplayer instanceof Object && 'server' in multiplayer) {
      server = multiplayer.server;
      multiplayer = true;
    }

    this.multiplayer = multiplayer;

    this.reducer = CreateGameReducer({
      game: game,
      numPlayers: numPlayers,
      multiplayer: multiplayer
    });

    if (ai !== undefined && multiplayer === undefined) {
      var bot = new ai.bot({ game: game, enumerate: ai.enumerate });

      this.step = function () {
        var state = _this.store.getState();
        var playerID = state.ctx.actionPlayers[0];

        var _bot$play = bot.play(state, playerID),
            action = _bot$play.action,
            metadata = _bot$play.metadata;

        if (action) {
          action.payload.metadata = metadata;
          _this.store.dispatch(action);
        }

        return action;
      };
    }

    this.reset = function () {
      _this.store.dispatch(reset());
    };
    this.undo = function () {
      _this.store.dispatch(undo());
    };
    this.redo = function () {
      _this.store.dispatch(redo());
    };

    this.store = null;

    if (multiplayer) {
      this.multiplayerClient = new Multiplayer({
        gameID: gameID,
        playerID: playerID,
        gameName: game.name,
        numPlayers: numPlayers,
        server: server,
        socketOpts: socketOpts
      });
      this.store = this.multiplayerClient.createStore(this.reducer, enhancer);
    } else {
      this.store = redux.createStore(this.reducer, enhancer);

      // If no playerID was provided, set it to undefined.
      if (this.playerID === null) {
        this.playerID = undefined;
      }
    }

    this.createDispatchers();
  }

  createClass(_ClientImpl, [{
    key: 'subscribe',
    value: function subscribe(fn) {
      this.store.subscribe(fn);

      if (this.multiplayerClient) {
        this.multiplayerClient.subscribe(fn);
      }
    }
  }, {
    key: 'getState',
    value: function getState() {
      var state = this.store.getState();

      // isActive.

      var isActive = true;

      var canPlayerMakeMove = this.game.flow.canPlayerMakeMove(state.G, state.ctx, this.playerID);

      if (this.multiplayer && !canPlayerMakeMove) {
        isActive = false;
      }

      if (!this.multiplayer && this.playerID !== null && this.playerID !== undefined && !canPlayerMakeMove) {
        isActive = false;
      }

      if (state.ctx.gameover !== undefined) {
        isActive = false;
      }

      // Secrets are normally stripped on the server,
      // but we also strip them here so that game developers
      // can see their effects while prototyping.
      var G = this.game.playerView(state.G, state.ctx, this.playerID);

      // Combine into return value.
      var ret = _extends({}, state, { isActive: isActive, G: G });

      if (this.multiplayerClient) {
        var isConnected = this.multiplayerClient.isConnected;
        ret = _extends({}, ret, { isConnected: isConnected });
      }

      return ret;
    }
  }, {
    key: 'connect',
    value: function connect() {
      if (this.multiplayerClient) {
        this.multiplayerClient.connect();
      }
    }
  }, {
    key: 'createDispatchers',
    value: function createDispatchers() {
      this.moves = createMoveDispatchers(this.game.moveNames, this.store, this.playerID, this.credentials, this.multiplayer);

      this.events = createEventDispatchers(this.game.flow.eventNames, this.store, this.playerID, this.credentials, this.multiplayer);
    }
  }, {
    key: 'updatePlayerID',
    value: function updatePlayerID(playerID) {
      this.playerID = playerID;
      this.createDispatchers();

      if (this.multiplayerClient) {
        this.multiplayerClient.updatePlayerID(playerID);
      }
    }
  }, {
    key: 'updateGameID',
    value: function updateGameID(gameID) {
      this.gameID = gameID;
      this.createDispatchers();

      if (this.multiplayerClient) {
        this.multiplayerClient.updateGameID(gameID);
      }
    }
  }, {
    key: 'updateCredentials',
    value: function updateCredentials(credentials) {
      this.credentials = credentials;
      this.createDispatchers();
    }
  }]);
  return _ClientImpl;
}();

/**
 * Client
 *
 * boardgame.io JS client.
 *
 * @param {...object} game - The return value of `Game`.
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }
 *                                  to make a multiplayer client. The second
 *                                  syntax specifies a non-default socket server.
 * @param {...object} socketOpts - Options to pass to socket.io.
 * @param {...object} gameID - The gameID that you want to connect to.
 * @param {...object} playerID - The playerID associated with this client.
 * @param {...string} credentials - The authentication credentials associated with this client.
 *
 * Returns:
 *   A JS object that provides an API to interact with the
 *   game by dispatching moves and events.
 */


function Client$1(opts) {
  return new _ClientImpl(opts);
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Client
 *
 * boardgame.io React Native client.
 *
 * @param {...object} game - The return value of `Game`.
 * @param {...object} numPlayers - The number of players.
 * @param {...object} board - The React component for the game.
 * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }
 *                                  to make a multiplayer client. The second
 *                                  syntax specifies a non-default socket server.
 * @param {...object} enhancer - Optional enhancer to send to the Redux store
 *
 * Returns:
 *   A React Native component that wraps board and provides an
 *   API through props for it to interact with the framework
 *   and dispatch actions such as MAKE_MOVE.
 */
function Client$$1(_ref) {
  var _class, _temp;

  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      board = _ref.board,
      multiplayer = _ref.multiplayer,
      enhancer = _ref.enhancer;

  /*
   * WrappedBoard
   *
   * The main React component that wraps the passed in
   * board component and adds the API to its props.
   */
  return _temp = _class = function (_React$Component) {
    inherits(WrappedBoard, _React$Component);

    function WrappedBoard(props) {
      classCallCheck(this, WrappedBoard);

      var _this = possibleConstructorReturn(this, (WrappedBoard.__proto__ || Object.getPrototypeOf(WrappedBoard)).call(this, props));

      _this.client = Client$1({
        game: game,
        numPlayers: numPlayers,
        multiplayer: multiplayer,
        gameID: props.gameID,
        playerID: props.playerID,
        credentials: props.credentials,
        socketOpts: {
          transports: ['websocket']
        },
        enhancer: enhancer
      });

      _this.client.subscribe(function () {
        return _this.forceUpdate();
      });
      return _this;
    }

    createClass(WrappedBoard, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (nextProps.gameID != this.props.gameID) {
          this.client.updateGameID(nextProps.gameID);
        }
        if (nextProps.playerID != this.props.playerID) {
          this.client.updatePlayerID(nextProps.playerID);
        }
        if (nextProps.credentials != this.props.credentials) {
          this.client.updateCredentials(nextProps.credentials);
        }
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        this.client.connect();
      }
    }, {
      key: 'render',
      value: function render() {
        var _board = null;

        var state = this.client.getState();
        var _props = this.props,
            gameID = _props.gameID,
            playerID = _props.playerID,
            rest = objectWithoutProperties(_props, ['gameID', 'playerID']);


        if (board) {
          _board = React.createElement(board, _extends({}, state, rest, {
            gameID: gameID,
            playerID: playerID,
            isMultiplayer: multiplayer !== undefined,
            moves: this.client.moves,
            events: this.client.events,
            reset: this.client.reset,
            undo: this.client.undo,
            redo: this.client.redo
          }));
        }

        return _board;
      }
    }]);
    return WrappedBoard;
  }(React.Component), _class.propTypes = {
    // The ID of a game to connect to.
    // Only relevant in multiplayer.
    gameID: PropTypes.string,
    // The ID of the player associated with this client.
    // Only relevant in multiplayer.
    playerID: PropTypes.string,
    // This client's authentication credentials.
    // Only relevant in multiplayer.
    credentials: PropTypes.string
  }, _class.defaultProps = {
    gameID: 'default',
    playerID: null,
    credentials: null
  }, _temp;
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

exports.Client = Client$$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));
