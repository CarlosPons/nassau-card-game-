(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('flatted')) :
	typeof define === 'function' && define.amd ? define(['exports', 'flatted'], factory) :
	(factory((global.Core = {}),global.Flatted));
}(this, (function (exports,flatted) { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};













var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};





















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Standard move that simulates passing.
 *
 * Creates two objects in G:
 * passOrder - An array of playerIDs capturing passes in the pass order.
 * allPassed - Set to true when all players have passed.
 */
var Pass = function Pass(G, ctx) {
  var passOrder = [];
  if (G.passOrder !== undefined) {
    passOrder = G.passOrder;
  }
  var playerID = ctx.playerID;
  passOrder.push(playerID);
  G = _extends({}, G, { passOrder: passOrder });
  if (passOrder.length >= ctx.numPlayers) {
    G.allPassed = true;
  }
  return G;
};

/**
 * Event to change the actionPlayers array.
 * @param {object} state - The game state.
 * @param {object} arg - An array of playerID's or <object> of:
 *   {
 *     value: [],   // array of playerID's (optional if all is set).
 *     all: true,   // set value to all playerID's
 *     once: true,  // players have one move.
 *   }
 */
function SetActionPlayers(state, arg) {
  var _actionPlayersOnce = false;
  var actionPlayers = [];

  if (arg.once) {
    _actionPlayersOnce = true;
  }

  if (arg.value) {
    actionPlayers = arg.value;
  }

  if (arg.all) {
    actionPlayers = [].concat(toConsumableArray(state.ctx.playOrder));
  }

  if (Array.isArray(arg)) {
    actionPlayers = arg;
  }

  return _extends({}, state, {
    ctx: _extends({}, state.ctx, { actionPlayers: actionPlayers, _actionPlayersOnce: _actionPlayersOnce })
  });
}

/**
 * Converts a playOrderPos index into its value in playOrder.
 * @param {Array} playOrder - An array of player ID's.
 * @param {number} playOrderPos - An index into the above.
 */
function getCurrentPlayer(playOrder, playOrderPos) {
  return playOrder[playOrderPos] + '';
}

/**
 * Called at the start of a phase to initialize turn order state.
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turnOrder - A turn order object for this phase.
 */
function InitTurnOrderState(G, ctx, turnOrder) {
  var playOrderPos = void 0;
  var actionPlayers = void 0;

  var t = turnOrder.first(G, ctx);

  if (t.playOrderPos !== undefined) {
    playOrderPos = t.playOrderPos;
  } else {
    playOrderPos = t;
  }

  var currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);

  if (t.actionPlayers !== undefined) {
    actionPlayers = t.actionPlayers;
  } else {
    actionPlayers = [currentPlayer];
  }

  return _extends({}, ctx, { currentPlayer: currentPlayer, playOrderPos: playOrderPos, actionPlayers: actionPlayers });
}

/**
 * Called at the end of each turn to update the turn order state.
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turnOrder - A turn order object for this phase.
 * @param {string} nextPlayer - An optional argument to endTurn that
                                may specify the next player.
 */
function UpdateTurnOrderState(G, ctx, turnOrder, nextPlayer) {
  var playOrderPos = ctx.playOrderPos;
  var currentPlayer = ctx.currentPlayer;
  var actionPlayers = ctx.actionPlayers;
  var endPhase = false;

  if (ctx.playOrder.includes(nextPlayer)) {
    playOrderPos = ctx.playOrder.indexOf(nextPlayer);
    currentPlayer = nextPlayer;
    actionPlayers = [currentPlayer];
  } else {
    var t = turnOrder.next(G, ctx);

    if (t == undefined) {
      endPhase = true;
    } else {
      if (t.playOrderPos !== undefined) {
        playOrderPos = t.playOrderPos;
      } else {
        playOrderPos = t;
      }

      currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);

      if (t.actionPlayers !== undefined) {
        actionPlayers = t.actionPlayers;
      } else {
        actionPlayers = [currentPlayer];
      }
    }
  }

  ctx = _extends({}, ctx, {
    playOrderPos: playOrderPos,
    currentPlayer: currentPlayer,
    actionPlayers: actionPlayers
  });

  return { endPhase: endPhase, ctx: ctx };
}

/**
 * Set of different turn orders possible in a phase.
 * These are meant to be passed to the `turnOrder` setting
 * in the flow objects.
 *
 * Each object defines the first player when the phase / game
 * begins, and also a function `next` to determine who the
 * next player is when the turn ends.
 *
 * first / next can also return an object of type
 * { playOrderPos, actionPlayers }
 * in which case they can also set actionPlayers simultaneously.
 *
 * The phase ends if next() returns undefined.
 */
var TurnOrder = {
  /**
   * DEFAULT
   *
   * The default round-robin turn order.
   */
  DEFAULT: {
    first: function first(G, ctx) {
      return ctx.playOrderPos;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * ONCE
   *
   * Another round-robin turn order, but goes around just once.
   * The phase ends after all players have played.
   */
  ONCE: {
    first: function first() {
      return 0;
    },
    next: function next(G, ctx) {
      if (ctx.playOrderPos < ctx.playOrder.length - 1) {
        return ctx.playOrderPos + 1;
      }
    }
  },

  /**
   * ANY
   *
   * currentPlayer switches around in round-robin fashion, but any player can play on each turn.
   */
  ANY: {
    first: function first(G, ctx) {
      return {
        actionPlayers: [].concat(toConsumableArray(ctx.playOrder)),
        playOrderPos: ctx.playOrderPos
      };
    },
    next: function next(G, ctx) {
      var playOrderPos = (ctx.playOrderPos + 1) % ctx.playOrder.length;
      return { actionPlayers: [].concat(toConsumableArray(ctx.playOrder)), playOrderPos: playOrderPos };
    }
  },

  /**
   * SKIP
   *
   * Round-robin, but skips over any players that have passed.
   * Meant to be used with Pass above.
   */

  SKIP: {
    first: function first(G, ctx) {
      return ctx.playOrderPos;
    },
    next: function next(G, ctx) {
      if (G.allPassed) return;
      var playOrderPos = ctx.playOrderPos;
      for (var i = 0; i < ctx.playOrder.length; i++) {
        playOrderPos = (playOrderPos + 1) % ctx.playOrder.length;
        if (!G.passOrder.includes(ctx.playOrder[playOrderPos] + '')) {
          return playOrderPos;
        }
      }
    }
  }
};

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) {
    me.s0 += 1;
  }
  me.s1 -= mash(seed);
  if (me.s1 < 0) {
    me.s1 += 1;
  }
  me.s2 -= mash(seed);
  if (me.s2 < 0) {
    me.s2 += 1;
  }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;
  if (state) {
    if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) == 'object') copy(state, xg);
    prng.state = function () {
      return copy(xg, {});
    };
  }
  return prng;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */
var Random = function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(ctx) {
    classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = ctx._random || { seed: '0' };
  }

  /**
   * Updates ctx with the PRNG state.
   * @param {object} ctx - The ctx object to update.
   */


  createClass(Random, [{
    key: 'update',
    value: function update(ctx) {
      return _extends({}, ctx, { _random: this.state });
    }

    /**
     * Attaches the Random API to ctx.
     * @param {object} ctx - The ctx object to attach to.
     */

  }, {
    key: 'attach',
    value: function attach(ctx) {
      return _extends({}, ctx, { random: this._api() });
    }

    /**
     * Generate a random number.
     */

  }, {
    key: '_random',
    value: function _random() {
      var R = this.state;

      var fn = void 0;
      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, { state: true });
      } else {
        fn = new alea('', { state: R.prngstate });
      }

      var number = fn();

      this.state = _extends({}, R, {
        prngstate: fn.state()
      });

      return number;
    }
  }, {
    key: '_api',
    value: function _api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      };

      // Generate functions for predefined dice values D4 - D20.
      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];
        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _extends({}, predefined, {

        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        }
      });
    }
  }]);
  return Random;
}();

/**
 * Removes the attached Random api from ctx.
 *
 * @param {object} ctx - The ctx object with the Random API attached.
 * @returns {object} A plain ctx object without the Random API.
 */
Random.detach = function (ctx) {
  var random = ctx.random,
      rest = objectWithoutProperties(ctx, ['random']); // eslint-disable-line no-unused-vars

  return rest;
};

/**
 * Generates a new seed from the current date / time.
 */
Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var MAKE_MOVE = 'MAKE_MOVE';
var GAME_EVENT = 'GAME_EVENT';
var RESTORE = 'RESTORE';
var RESET = 'RESET';
var UNDO = 'UNDO';
var REDO = 'REDO';

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */


/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */


/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials },
    automatic: true
  };
};

/**
 * Used to reset the Redux store's state.
 * @param {object} state - The state to restore.
 */


/**
 * Used to reset the game state.
 */


/**
 * Used to undo the last move.
 */


/**
 * Used to redo the last undone move.
 */

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Events
 */
var Events = function () {
  function Events(flow, playerID) {
    classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }

  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  createClass(Events, [{
    key: 'attach',
    value: function attach(ctx) {
      var _this = this;

      var events = {};

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({ key: key, args: args });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _extends({}, ctx, { events: events });
    }

    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: 'update',
    value: function update(state) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.dispatch[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var action = automaticGameEvent(item.key, item.args, this.playerID);
          state = _extends({}, state, this.flow.processGameEvent(state, action));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return state;
    }
  }]);
  return Events;
}();

/**
 * Detaches the Events API from ctx.
 * @param {object} ctx - The ctx object to strip.
 */
Events.detach = function (ctx) {
  var events = ctx.events,
      rest = objectWithoutProperties(ctx, ['events']); // eslint-disable-line no-unused-vars

  return rest;
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Helper to create a reducer that manages ctx (with the
 * ability to also update G).
 *
 * You probably want to use FlowWithPhases below, but you might
 * need to use this directly if you are creating a very customized
 * game flow that it cannot handle.
 *
 * @param {...object} ctx - Function with the signature
 *                          numPlayers => ctx
 *                          that determines the initial value of ctx.
 * @param {...object} events - Object containing functions
 *                             named after events that this
 *                             reducer will handle. Each function
 *                             has the following signature:
 *                             ({G, ctx}) => {G, ctx}
 * @param {...object} processMove - A function that's called whenever a move is made.
 *                                  (state, action, dispatch) => state.
 * @param {...object} optimisticUpdate - (G, ctx, move) => boolean
 *                                       Control whether a move should
 *                                       be executed optimistically on
 *                                       the client while waiting for
 *                                       the result of execution from
 *                                       the server.
 * @param {...object} canMakeMove - (G, ctx, moveName) => boolean
 *                                  Predicate to determine whether a
 *                                  particular move is allowed at
 *                                  this time.
 *
 * @param {...object} canUndoMove - (G, ctx, moveName) => boolean
 *                                  Predicate to determine whether a
 *                                  particular move is undoable at this
 *                                  time.
 */
function Flow(_ref) {
  var ctx = _ref.ctx,
      events = _ref.events,
      init = _ref.init,
      _processMove = _ref.processMove,
      optimisticUpdate = _ref.optimisticUpdate,
      _canMakeMove = _ref.canMakeMove,
      canUndoMove = _ref.canUndoMove;

  if (!ctx) ctx = function ctx() {
    return {};
  };
  if (!events) events = {};
  if (!init) init = function init(state) {
    return state;
  };
  if (!_processMove) _processMove = function processMove(state) {
    return state;
  };
  if (!_canMakeMove) _canMakeMove = function canMakeMove() {
    return true;
  };
  if (!canUndoMove) canUndoMove = function canUndoMove() {
    return true;
  };

  if (optimisticUpdate === undefined) {
    optimisticUpdate = function optimisticUpdate() {
      return true;
    };
  }

  var dispatch = function dispatch(state, action) {
    var payload = action.payload;

    if (events.hasOwnProperty(payload.type)) {
      var context = { playerID: payload.playerID, dispatch: dispatch };
      var args = [state].concat(payload.args);
      var oldLog = state.log || [];
      var log = [].concat(toConsumableArray(oldLog), [action]);
      var newState = events[payload.type].apply(context, args);
      return _extends({}, newState, { log: log });
    }
    return state;
  };

  return {
    ctx: ctx,
    init: init,
    canUndoMove: canUndoMove,

    eventNames: Object.getOwnPropertyNames(events),

    processMove: function processMove(state, action) {
      return _processMove(state, action, dispatch);
    },

    processGameEvent: function processGameEvent(state, action) {
      return dispatch(state, action, dispatch);
    },

    optimisticUpdate: optimisticUpdate,

    canPlayerCallEvent: function canPlayerCallEvent(G, ctx, playerID) {
      return ctx.currentPlayer == playerID;
    },

    canPlayerMakeMove: function canPlayerMakeMove(G, ctx, playerID) {
      var actionPlayers = ctx.actionPlayers || [];
      return actionPlayers.includes(playerID);
    },

    canMakeMove: function canMakeMove(G, ctx, moveName) {
      // Disallow moves once the game is over.
      if (ctx.gameover !== undefined) return false;
      // User-provided move validation.
      return _canMakeMove(G, ctx, moveName);
    }
  };
}

/**
 * FlowWithPhases
 *
 * A very customizable game flow that introduces phases to the
 * game. Each phase can be configured with:
 * - A custom turn order.
 * - Automatically executed setup / cleanup code.
 * - Custom phase end conditions.
 * - A move whitelist that disallows other moves during the phase.
 *
 * @param {...object} movesPerTurn - End the turn automatically after a certain number
 *                                   of moves (default: undefined, i.e. the turn does
 *                                   not automatically end after a certain number of moves).
 *
 * @param {...object} endTurnIf - The turn automatically ends if this
 *                                returns a truthy value
 *                                (checked after each move).
 *                                If the return value is a playerID,
 *                                that player is the next player
 *                                (instead of following the turn order).
 *                                (G, ctx) => boolean|string
 *
 * @param {...object} endGameIf - The game automatically ends if this function
 *                                returns anything (checked after each move).
 *                                The return value is available at ctx.gameover.
 *                                (G, ctx) => {}
 *
 * @param {...object} onTurnBegin - Any code to run when a turn begins.
 *                                 (G, ctx) => G
 *
 * @param {...object} onTurnEnd - Any code to run when a turn ends.
 *                                (G, ctx) => G
 *
 * @param {...object} onMove - Any code to run at the end of a move.
 *                             (G, ctx, { type: 'moveName', args: [] }) => G
 *
 * @param {...object} turnOrder - Customize the turn order (see turn-order.js).
 *
 * @param {...object} endTurn - Set to false to disable the `endTurn` event.
 *
 * @param {...object} endPhase - Set to false to disable the `endPhase` event.
 *
 * @param {...object} endGame - Set to true to enable the `endGame` event.
 *
 * @param {...object} setActionPlayers - Set to true to enable the `setActionPlayers` event.
 *
 * @param {...object} allowedMoves - List of moves that are allowed.
 *                                   This can be either a list of
 *                                   move names or a function with the
 *                                   signature (G, ctx) => [].
 *                                   (default: null, i.e. all moves are allowed).
 *
 * @param {...object} undoableMoves - List of moves that are undoable,
 *                                   (default: null, i.e. all moves are undoable).
 *
 *
 * @param {...object} optimisticUpdate - (G, ctx, move) => boolean
 *                                       Control whether a move should
 *                                       be executed optimistically on
 *                                       the client while waiting for
 *                                       the result of execution from
 *                                       the server.
 *
 * @param {...object} phases - A list of phases in the game.
 *
 * Each phase is described by an object:
 *
 * All the properties below override their global equivalents
 * above whenever they are defined (i.e. the global setting
 * is used if a phase-specific setting is absent).
 *
 * {
 *   name: 'phase_name',
 *
 *   // Any setup code to run before the phase begins.
 *   onPhaseBegin: (G, ctx) => G,
 *
 *   // Any cleanup code to run after the phase ends.
 *   onPhaseEnd: (G, ctx) => G,
 *
 *   // The phase ends if this function returns a truthy value.
 *   // If the return value is the name of another phase,
 *   // that will be chosen as the next phase (as opposed
 *   // to the next one in round-robin order).
 *   endPhaseIf: (G, ctx) => boolean|string,
 *
 *   Phase-specific options that override their global equivalents:
 *
 *   // A phase-specific endTurnIf.
 *   endTurnIf: (G, ctx) => boolean,
 *
 *   // A phase-specific endGameIf.
 *   endGameIf: (G, ctx) => {},
 *
 *   // A phase-specific onTurnBegin
 *   onTurnBegin: (G, ctx) => G,
 *
 *   // A phase-specific onTurnEnd.
 *   onTurnEnd: (G, ctx) => G,
 *
 *   // A phase-specific onMove.
 *   onMove - (G, ctx) => G,
 *
 *   // A phase-specific turnOrder.
 *   turnOrder: TurnOrder.DEFAULT,
 *
 *   // A phase-specific movesPerTurn.
 *   movesPerTurn: integer,
 *
 *   // List of moves or a function that returns a list of moves
 *   // that are allowed in this phase.
 *   allowedMoves: (G, ctx) => ['moveA', ...],
 *
 *   // List of moves that are undoable.
 *   undoableMoves: ['moveA', ...],
 * }
 */
function FlowWithPhases(_ref2) {
  var phases = _ref2.phases,
      movesPerTurn = _ref2.movesPerTurn,
      endTurnIf = _ref2.endTurnIf,
      endGameIf = _ref2.endGameIf,
      onTurnBegin = _ref2.onTurnBegin,
      onTurnEnd = _ref2.onTurnEnd,
      onMove = _ref2.onMove,
      turnOrder = _ref2.turnOrder,
      endTurn = _ref2.endTurn,
      endPhase = _ref2.endPhase,
      endGame = _ref2.endGame,
      setActionPlayers = _ref2.setActionPlayers,
      undoableMoves = _ref2.undoableMoves,
      allowedMoves = _ref2.allowedMoves,
      _optimisticUpdate = _ref2.optimisticUpdate;

  // Attach defaults.
  if (endPhase === undefined && phases) {
    endPhase = true;
  }
  if (endTurn === undefined) {
    endTurn = true;
  }
  if (endGame === undefined) {
    endGame = false;
  }
  if (setActionPlayers === undefined) {
    setActionPlayers = false;
  }
  if (_optimisticUpdate === undefined) {
    _optimisticUpdate = function optimisticUpdate() {
      return true;
    };
  }
  if (!phases) phases = [{ name: 'default' }];
  if (!endTurnIf) endTurnIf = function endTurnIf() {
    return false;
  };
  if (!endGameIf) endGameIf = function endGameIf() {
    return undefined;
  };
  if (!onTurnBegin) onTurnBegin = function onTurnBegin(G) {
    return G;
  };
  if (!onTurnEnd) onTurnEnd = function onTurnEnd(G) {
    return G;
  };
  if (!onMove) onMove = function onMove(G) {
    return G;
  };
  if (!turnOrder) turnOrder = TurnOrder.DEFAULT;
  if (allowedMoves === undefined) allowedMoves = null;
  if (undoableMoves === undefined) undoableMoves = null;

  var phaseKeys = [];
  var phaseMap = {};

  for (var i = 0; i < phases.length; i++) {
    var conf = phases[i];
    phaseKeys.push(conf.name);
    phaseMap[conf.name] = conf;

    if (conf.endPhaseIf === undefined) {
      conf.endPhaseIf = function () {
        return false;
      };
    }
    if (conf.onPhaseBegin === undefined) {
      conf.onPhaseBegin = function (G) {
        return G;
      };
    }
    if (conf.onPhaseEnd === undefined) {
      conf.onPhaseEnd = function (G) {
        return G;
      };
    }
    if (conf.movesPerTurn === undefined) {
      conf.movesPerTurn = movesPerTurn;
    }
    if (conf.endTurnIf === undefined) {
      conf.endTurnIf = endTurnIf;
    }
    if (conf.endGameIf === undefined) {
      conf.endGameIf = endGameIf;
    }
    if (conf.onTurnBegin === undefined) {
      conf.onTurnBegin = onTurnBegin;
    }
    if (conf.onTurnEnd === undefined) {
      conf.onTurnEnd = onTurnEnd;
    }
    if (conf.onMove === undefined) {
      conf.onMove = onMove;
    }
    if (conf.turnOrder === undefined) {
      conf.turnOrder = turnOrder;
    }
    if (conf.undoableMoves === undefined) {
      conf.undoableMoves = undoableMoves;
    }
    if (conf.allowedMoves === undefined) {
      conf.allowedMoves = allowedMoves;
    }
    if (typeof conf.allowedMoves !== 'function') {
      (function () {
        var t = conf.allowedMoves;
        conf.allowedMoves = function () {
          return t;
        };
      })();
    }
  }

  var shouldEndPhase = function shouldEndPhase(_ref3) {
    var G = _ref3.G,
        ctx = _ref3.ctx;

    var conf = phaseMap[ctx.phase];
    return conf.endPhaseIf(G, ctx);
  };

  var shouldEndTurn = function shouldEndTurn(_ref4) {
    var G = _ref4.G,
        ctx = _ref4.ctx;

    var conf = phaseMap[ctx.phase];

    var currentPlayerMoves = ctx.stats.turn.numMoves[ctx.currentPlayer] || 0;
    if (conf.movesPerTurn && currentPlayerMoves >= conf.movesPerTurn) {
      return true;
    }
    return conf.endTurnIf(G, ctx);
  };

  // Helper to perform start-of-phase initialization.
  var startPhase = function startPhase(state, config) {
    var G = config.onPhaseBegin(state.G, state.ctx);
    var ctx = InitTurnOrderState(state.G, state.ctx, config.turnOrder);

    // Reset stats.
    ctx.stats = _extends({}, ctx.stats, {
      phase: _extends({}, ctx.stats.phase, {
        numMoves: {},
        allPlayed: false
      })
    });

    var allowedMoves = config.allowedMoves(G, ctx);
    return _extends({}, state, { G: G, ctx: _extends({}, ctx, { allowedMoves: allowedMoves }) });
  };

  var startTurn = function startTurn(state, config) {
    var G = config.onTurnBegin(state.G, state.ctx);

    var plainCtx = state.ctx;
    plainCtx = Random.detach(plainCtx);
    plainCtx = Events.detach(plainCtx);
    var _undo = [{ G: G, ctx: plainCtx }];

    var ctx = _extends({}, state.ctx);
    ctx.allowedMoves = config.allowedMoves(G, ctx);

    // Reset stats.
    ctx.stats = _extends({}, ctx.stats, {
      turn: _extends({}, ctx.stats.turn, {
        numMoves: {},
        allPlayed: false
      })
    });

    return _extends({}, state, { G: G, ctx: ctx, _undo: _undo, _redo: [] });
  };

  var startGame = function startGame(state, config) {
    state = startPhase(state, config);
    state = startTurn(state, config);
    return state;
  };

  /**
   * endPhase (game event)
   *
   * Ends the current phase.
   * Also runs any phase cleanup code and setup code for the
   * next phase (if any).
   *
   * The next phase is chosen in a round-robin fashion, with the
   * option to override that by passing nextPhase.
   */
  function endPhaseEvent(state, nextPhase, cascadeDepth) {
    var G = state.G;
    var ctx = state.ctx;

    // Run any cleanup code for the phase that is about to end.
    var conf = phaseMap[ctx.phase];
    G = conf.onPhaseEnd(G, ctx);

    var gameover = conf.endGameIf(G, ctx);
    if (gameover !== undefined) {
      return _extends({}, state, { G: G, ctx: _extends({}, ctx, { gameover: gameover }) });
    }

    // Update the phase.
    if (nextPhase in phaseMap) {
      ctx = _extends({}, ctx, { phase: nextPhase });
    } else {
      var index = phaseKeys.indexOf(ctx.phase);
      index = (index + 1) % phases.length;
      var phase = phases[index].name;
      ctx = _extends({}, ctx, { phase: phase });
    }

    // Run any setup code for the new phase.
    state = startPhase(_extends({}, state, { G: G, ctx: ctx }), phaseMap[ctx.phase]);

    var origTurn = state.ctx.turn;

    // End the new phase automatically if necessary.
    // In order to avoid infinite loops, this is called
    // a finite number of times.
    if (!cascadeDepth) cascadeDepth = 0;
    if (cascadeDepth < phases.length - 1) {
      var end = shouldEndPhase(state);
      if (end) {
        state = this.dispatch(state, automaticGameEvent('endPhase', [end, cascadeDepth + 1], this.playerID));
      }
    }

    // End turn if endTurnIf returns something
    // (and the turn has not already been ended by a nested endPhase call).
    var endTurn = shouldEndTurn(state);
    if (endTurn && state.ctx.turn == origTurn) {
      state = this.dispatch(state, automaticGameEvent('endTurn', [endTurn], this.playerID));
    }

    return state;
  }

  /**
   * endTurn (game event)
   *
   * Ends the current turn.
   * Passes the turn to the next turn in a round-robin fashion.
   */
  function endTurnEvent(state, nextPlayer) {
    var G = state.G,
        ctx = state.ctx;


    var conf = phaseMap[ctx.phase];

    // Prevent ending the turn if movesPerTurn haven't been made.
    var currentPlayerMoves = ctx.stats.turn.numMoves[ctx.currentPlayer] || 0;
    if (conf.movesPerTurn && currentPlayerMoves < conf.movesPerTurn) {
      return state;
    }

    // Run turn-end triggers.
    G = conf.onTurnEnd(G, ctx);

    // Update gameover.
    var gameover = conf.endGameIf(G, ctx);
    if (gameover !== undefined) {
      return _extends({}, state, { G: G, ctx: _extends({}, ctx, { gameover: gameover }) });
    }

    var endPhase = false;

    // Update turn order state.
    {
      var _UpdateTurnOrderState = UpdateTurnOrderState(G, ctx, conf.turnOrder, nextPlayer),
          a = _UpdateTurnOrderState.endPhase,
          b = _UpdateTurnOrderState.ctx;

      endPhase = a;
      ctx = b;
    }

    // Update turn.
    var turn = ctx.turn + 1;

    // Update state.
    ctx = _extends({}, ctx, { turn: turn });

    // End phase if condition is met.
    var endPhaseArg = shouldEndPhase(state);
    if (endPhaseArg) {
      endPhase = true;
    }

    if (endPhase) {
      return this.dispatch(_extends({}, state, { G: G, ctx: ctx }), automaticGameEvent('endPhase', [endPhaseArg], this.playerID));
    }

    return startTurn(_extends({}, state, { G: G, ctx: ctx }), conf);
  }

  function endGameEvent(state, arg) {
    if (arg === undefined) {
      arg = true;
    }

    return _extends({}, state, { ctx: _extends({}, state.ctx, { gameover: arg }) });
  }

  function updateStats(state, key, playerID) {
    var moves = (state.ctx.stats[key].numMoves[playerID] || 0) + 1;
    var numMoves = _extends({}, state.ctx.stats[key].numMoves, defineProperty({}, playerID, moves));
    var t = _extends({}, state.ctx.stats[key], { numMoves: numMoves });

    if (Object.keys(numMoves).length == state.ctx.numPlayers) {
      t.allPlayed = true;
    }

    var stats = _extends({}, state.ctx.stats, defineProperty({}, key, t));
    var ctx = _extends({}, state.ctx, { stats: stats });

    return _extends({}, state, { ctx: ctx });
  }

  function processMove(state, action, dispatch) {
    var conf = phaseMap[state.ctx.phase];

    state = updateStats(state, 'turn', action.playerID);
    state = updateStats(state, 'phase', action.playerID);

    // Update actionPlayers if _actionPlayersOnce is set.
    var actionPlayers = state.ctx.actionPlayers;
    if (state.ctx._actionPlayersOnce == true) {
      var playerID = action.playerID;
      actionPlayers = actionPlayers.filter(function (id) {
        return id !== playerID;
      });
    }

    state = _extends({}, state, {
      ctx: _extends({}, state.ctx, {
        actionPlayers: actionPlayers
      })
    });

    var G = conf.onMove(state.G, state.ctx, action);
    state = _extends({}, state, { G: G });

    var origTurn = state.ctx.turn;
    var gameover = conf.endGameIf(state.G, state.ctx);

    // End the phase automatically if endPhaseIf is true or if endGameIf returns.
    var endPhase = shouldEndPhase(state);
    if (endPhase || gameover !== undefined) {
      state = dispatch(state, automaticGameEvent('endPhase', [endPhase], action.playerID));
      // Update to the new phase configuration
      conf = phaseMap[state.ctx.phase];
    }

    // End the turn automatically if endTurnIf is true or if endGameIf returns.
    // (but not if endPhase above already ends the turn).
    var endTurn = shouldEndTurn(state);
    if (state.ctx.turn == origTurn && (endTurn || gameover !== undefined)) {
      state = dispatch(state, automaticGameEvent('endTurn', [endTurn], action.playerID));
    }

    // End the game automatically if endGameIf returns.
    if (gameover !== undefined) {
      return _extends({}, state, { ctx: _extends({}, state.ctx, { gameover: gameover }) });
    }

    // Update allowedMoves.
    var allowedMoves = conf.allowedMoves(state.G, state.ctx);
    state = _extends({}, state, { ctx: _extends({}, state.ctx, { allowedMoves: allowedMoves }) });

    // Update undo / redo state.
    if (!endTurn) {
      var undo$$1 = state._undo || [];
      var moveType = action.type;

      var plainCtx = state.ctx;
      plainCtx = Random.detach(plainCtx);
      plainCtx = Events.detach(plainCtx);

      state = _extends({}, state, {
        _undo: [].concat(toConsumableArray(undo$$1), [{ G: state.G, ctx: plainCtx, moveType: moveType }]),
        _redo: []
      });
    }

    return state;
  }

  var canMakeMove = function canMakeMove(G, ctx, moveName) {
    var conf = phaseMap[ctx.phase];
    var moves = conf.allowedMoves(G, ctx);
    if (!moves) return true;
    return moves.includes(moveName);
  };

  var canUndoMove = function canUndoMove(G, ctx, moveName) {
    var conf = phaseMap[ctx.phase];
    if (!conf.undoableMoves) return true;
    return conf.undoableMoves.includes(moveName);
  };

  var enabledEvents = {};
  if (endTurn) {
    enabledEvents['endTurn'] = endTurnEvent;
  }
  if (endPhase) {
    enabledEvents['endPhase'] = endPhaseEvent;
  }
  if (endGame) {
    enabledEvents['endGame'] = endGameEvent;
  }
  if (setActionPlayers) {
    enabledEvents['setActionPlayers'] = SetActionPlayers;
  }

  return Flow({
    ctx: function ctx(numPlayers) {
      return {
        numPlayers: numPlayers,
        turn: 0,
        currentPlayer: '0',
        currentPlayerMoves: 0,
        playOrder: Array.from(Array(numPlayers), function (d, i) {
          return i + '';
        }),
        playOrderPos: 0,
        stats: { turn: { numMoves: {} }, phase: { numMoves: {} } },
        allPlayed: false,
        phase: phases[0].name
      };
    },
    init: function init(state) {
      return startGame(state, phases[0]);
    },
    optimisticUpdate: function optimisticUpdate(G, ctx, action) {
      // Some random code was executed.
      if (ctx._random !== undefined && ctx._random.prngstate !== undefined) {
        return false;
      }
      return _optimisticUpdate(G, ctx, action);
    },
    events: enabledEvents,
    processMove: processMove,
    canMakeMove: canMakeMove,
    canUndoMove: canUndoMove
  });
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Game
 *
 * Helper to generate the game move reducer. The returned
 * reducer has the following signature:
 *
 * (G, action, ctx) => {}
 *
 * You can roll your own if you like, or use any Redux
 * addon to generate such a reducer.
 *
 * The convention used in this framework is to
 * have action.type contain the name of the move, and
 * action.args contain any additional arguments as an
 * Array.
 *
 * Game({
 *   name: 'tic-tac-toe',
 *
 *   setup: (numPlayers) => {
 *     const G = {...};
 *     return G;
 *   },
 *
 *   moves: {
 *     'moveWithoutArgs': (G, ctx) => {
 *       return Object.assign({}, G, ...);
 *     },
 *     'moveWithArgs': (G, ctx, arg0, arg1) => {
 *       return Object.assign({}, G, ...);
 *     }
 *   },
 *
 *   playerView: (G, ctx, playerID) => { ... },
 *
 *   flow: {
 *     endGameIf: (G, ctx) => { ... },
 *     endTurnIf: (G, ctx) => { ... },
 *
 *     phases: [
 *       { name: 'A', setup: (G, ctx) => G, cleanup: (G, ctx) => G },
 *       { name: 'B', setup: (G, ctx) => G, cleanup: (G, ctx) => G },
 *       ...
 *     ]
 *   },
 * })
 *
 * @param {...object} setup - Function that returns the initial state of G.
 *
 * @param {...object} moves - A dictionary of move functions.
 *
 * @param {...object} playerView - A function that returns a
 *                                 derivative of G tailored for
 *                                 the specified player.
 *
 * @param {...object} flow - Customize the flow of the game (see flow.js).
 *                           Must contain the return value of Flow().
 *                           If it contains any other object, it is presumed to be a
 *                           configuration object for FlowWithPhases().
 *
 * @param {...object} seed - Seed for the PRNG.
 */
function Game(_ref) {
  var name = _ref.name,
      setup = _ref.setup,
      moves = _ref.moves,
      playerView = _ref.playerView,
      flow = _ref.flow,
      seed = _ref.seed;

  if (name === undefined) name = 'default';
  if (setup === undefined) setup = function setup() {
    return {};
  };
  if (moves === undefined) moves = {};
  if (playerView === undefined) playerView = function playerView(G) {
    return G;
  };

  if (!flow || flow.processGameEvent === undefined) {
    flow = FlowWithPhases(flow || {});
  }

  return {
    name: name,
    setup: setup,
    playerView: playerView,
    flow: flow,
    seed: seed,
    moveNames: Object.getOwnPropertyNames(moves),
    processMove: function processMove(G, action, ctx) {
      if (moves.hasOwnProperty(action.type)) {
        var context = { playerID: action.playerID };
        var ctxWithPlayerID = _extends({}, ctx, { playerID: action.playerID });
        var args = [G, ctxWithPlayerID].concat(action.args);
        return moves[action.type].apply(context, args);
      }
      return G;
    }
  };
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 * @param {...object} game - Return value of Game().
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true if we are in a multiplayer client.
 */
function CreateGameReducer(_ref) {
  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      multiplayer = _ref.multiplayer;

  if (!numPlayers) {
    numPlayers = 2;
  }

  var ctx = game.flow.ctx(numPlayers);

  var seed = game.seed;
  if (seed === undefined) {
    seed = Random.seed();
  }
  ctx._random = { seed: seed };

  var random = new Random(ctx);
  var ctxWithAPI = random.attach(ctx);

  var initial = {
    // User managed state.
    G: game.setup(ctxWithAPI),

    // Framework managed state.
    ctx: ctx,

    // A list of actions performed so far. Used by the
    // GameLog to display a journal of moves.
    log: [],

    // List of {G, ctx} pairs that can be undone.
    _undo: [],

    // List of {G, ctx} pairs that can be redone.
    _redo: [],

    // A monotonically non-decreasing ID to ensure that
    // state updates are only allowed from clients that
    // are at the same version that the server.
    _stateID: 0,

    // A snapshot of this object so that actions can be
    // replayed over it to view old snapshots.
    _initial: {}
  };

  var events = new Events(game.flow, ctx.currentPlayer);
  ctxWithAPI = events.attach(ctxWithAPI);

  var state = game.flow.init({ G: initial.G, ctx: ctxWithAPI });

  var _events$update = events.update(state),
      ctxWithEvents = _events$update.ctx;

  initial.G = state.G;
  initial._undo = state._undo;
  initial.ctx = ctxWithEvents;
  initial.ctx = random.update(initial.ctx);
  initial.ctx = Random.detach(initial.ctx);
  initial.ctx = Events.detach(initial.ctx);

  var deepCopy = function deepCopy(obj) {
    return flatted.parse(flatted.stringify(obj));
  };
  initial._initial = deepCopy(initial);

  /**
   * GameReducer
   *
   * Redux reducer that maintains the overall game state.
   * @param {object} state - The state before the action.
   * @param {object} action - A Redux action.
   */
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initial;
    var action = arguments[1];

    switch (action.type) {
      case GAME_EVENT:
        {
          // Process game events only on the server.
          // These events like `endTurn` typically
          // contain code that may rely on secret state
          // and cannot be computed on the client.
          if (multiplayer) {
            return state;
          }

          // Ignore the event if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerCallEvent(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random = new Random(state.ctx);
          // Initialize Events API.
          var _events = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          state = _extends({}, state, { ctx: _random.attach(state.ctx) });
          // Attach Events API to ctx.
          state = _extends({}, state, { ctx: _events.attach(state.ctx) });

          // Update state.
          var newState = game.flow.processGameEvent(state, action);
          // Trigger any events that were called via the Events API.
          newState = _events.update(newState);
          // Update ctx with PRNG state.
          var _ctx = _random.update(newState.ctx);
          // Detach Random API from ctx.
          _ctx = Random.detach(_ctx);
          // Detach Events API from ctx.
          _ctx = Events.detach(_ctx);

          return _extends({}, newState, { ctx: _ctx, _stateID: state._stateID + 1 });
        }

      case MAKE_MOVE:
        {
          // Check whether the game knows the move at all.
          if (!game.moveNames.includes(action.payload.type)) {
            return state;
          }

          // Ignore the move if it isn't allowed at this point.
          if (!game.flow.canMakeMove(state.G, state.ctx, action.payload.type)) {
            return state;
          }

          // Ignore the move if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerMakeMove(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random2 = new Random(state.ctx);
          // Initialize Events API.
          var _events2 = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          var _ctxWithAPI = _random2.attach(state.ctx);
          // Attach Events API to ctx.
          _ctxWithAPI = _events2.attach(_ctxWithAPI);

          // Process the move.
          var G = game.processMove(state.G, action.payload, _ctxWithAPI);
          if (G === undefined) {
            // the game declared the move as invalid.
            return state;
          }

          // Update ctx with PRNG state.
          var _ctx2 = _random2.update(state.ctx);
          // Detach Random API from ctx.
          _ctx2 = Random.detach(_ctx2);
          // Detach Events API from ctx.
          _ctx2 = Events.detach(_ctx2);

          // Undo changes to G if the move should not run on the client.
          if (multiplayer && !game.flow.optimisticUpdate(G, _ctx2, action.payload)) {
            G = state.G;
          }

          var log = [].concat(toConsumableArray(state.log), [action]);
          state = _extends({}, state, { G: G, ctx: _ctx2, log: log, _stateID: state._stateID + 1 });

          // If we're on the client, just process the move
          // and no triggers in multiplayer mode.
          // These will be processed on the server, which
          // will send back a state update.
          if (multiplayer) {
            return state;
          }

          // Allow the flow reducer to process any triggers that happen after moves.
          state = _extends({}, state, { ctx: _random2.attach(state.ctx) });
          state = _extends({}, state, { ctx: _events2.attach(state.ctx) });
          state = game.flow.processMove(state, action.payload);
          state = _events2.update(state);
          state = _extends({}, state, { ctx: _random2.update(state.ctx) });
          state = _extends({}, state, { ctx: Random.detach(state.ctx) });
          state = _extends({}, state, { ctx: Events.detach(state.ctx) });

          return state;
        }

      case RESTORE:
        {
          return action.state;
        }

      case RESET:
        {
          return initial;
        }

      case UNDO:
        {
          var _state = state,
              _undo = _state._undo,
              _redo = _state._redo;


          if (_undo.length < 2) {
            return state;
          }

          var last = _undo[_undo.length - 1];
          var restore = _undo[_undo.length - 2];

          // Only allow undoable moves to be undone.
          if (!game.flow.canUndoMove(state.G, state.ctx, last.moveType)) {
            return state;
          }

          return _extends({}, state, {
            G: restore.G,
            ctx: restore.ctx,
            _undo: _undo.slice(0, _undo.length - 1),
            _redo: [last].concat(toConsumableArray(_redo))
          });
        }

      case REDO:
        {
          var _state2 = state,
              _undo2 = _state2._undo,
              _redo2 = _state2._redo;


          if (_redo2.length == 0) {
            return state;
          }

          var first = _redo2[0];

          return _extends({}, state, {
            G: first.G,
            ctx: first.ctx,
            _undo: [].concat(toConsumableArray(_undo2), [first]),
            _redo: _redo2.slice(1)
          });
        }

      default:
        {
          return state;
        }
    }
  };
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * PlayerView reducers.
 */
var PlayerView = {
  /**
   * STRIP_SECRETS
   *
   * Reducer which removes a key named `secret` and
   * removes all the keys in `players`, except for the one
   * corresponding to the current playerID.
   */
  STRIP_SECRETS: function STRIP_SECRETS(G, ctx, playerID) {
    var r = _extends({}, G);

    if (r.secret !== undefined) {
      delete r.secret;
    }

    if (r.players) {
      r.players = defineProperty({}, playerID, r.players[playerID]);
    }

    return r;
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

exports.Game = Game;
exports.CreateGameReducer = CreateGameReducer;
exports.Flow = Flow;
exports.FlowWithPhases = FlowWithPhases;
exports.TurnOrder = TurnOrder;
exports.Pass = Pass;
exports.PlayerView = PlayerView;

Object.defineProperty(exports, '__esModule', { value: true });

})));
