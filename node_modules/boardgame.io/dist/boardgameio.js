(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('redux'), require('socket.io-client'), require('flatted'), require('react'), require('prop-types'), require('mousetrap')) :
	typeof define === 'function' && define.amd ? define(['redux', 'socket.io-client', 'flatted', 'react', 'prop-types', 'mousetrap'], factory) :
	(global.BoardgameIO = factory(global.Redux,global.io,global.Flatted,global.React,global.PropTypes,global.Mousetrap));
}(this, (function (redux,io,flatted,React,PropTypes,Mousetrap) { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

io = io && io.hasOwnProperty('default') ? io['default'] : io;
React = React && React.hasOwnProperty('default') ? React['default'] : React;
PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
Mousetrap = Mousetrap && Mousetrap.hasOwnProperty('default') ? Mousetrap['default'] : Mousetrap;

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var MAKE_MOVE = 'MAKE_MOVE';
var GAME_EVENT = 'GAME_EVENT';
var RESTORE = 'RESTORE';
var RESET = 'RESET';
var UNDO = 'UNDO';
var REDO = 'REDO';

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var makeMove = function makeMove(type, args, playerID, credentials) {
  return {
    type: MAKE_MOVE,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var gameEvent = function gameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials },
    automatic: true
  };
};

/**
 * Used to reset the Redux store's state.
 * @param {object} state - The state to restore.
 */
var restore = function restore(state) {
  return {
    type: RESTORE,
    state: state
  };
};

/**
 * Used to reset the game state.
 */
var reset = function reset() {
  return {
    type: RESET
  };
};

/**
 * Used to undo the last move.
 */
var undo = function undo() {
  return {
    type: UNDO
  };
};

/**
 * Used to redo the last undone move.
 */
var redo = function redo() {
  return {
    type: REDO
  };
};

var ActionCreators = Object.freeze({
	makeMove: makeMove,
	gameEvent: gameEvent,
	automaticGameEvent: automaticGameEvent,
	restore: restore,
	reset: reset,
	undo: undo,
	redo: redo
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

// The actions that are sent across the network.
var blacklistedActions = new Set([RESTORE]);

/**
 * Multiplayer
 *
 * Handles all the multiplayer interactions on the client-side.
 */
var Multiplayer = function () {
  /**
   * Creates a new Mutiplayer instance.
   * @param {object} socket - Override for unit tests.
   * @param {object} socketOpts - Options to pass to socket.io.
   * @param {string} gameID - The game ID to connect to.
   * @param {string} playerID - The player ID associated with this client.
   * @param {string} gameName - The game type (the `name` field in `Game`).
   * @param {string} numPlayers - The number of players.
   * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.
   */
  function Multiplayer() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        socket = _ref.socket,
        socketOpts = _ref.socketOpts,
        gameID = _ref.gameID,
        playerID = _ref.playerID,
        gameName = _ref.gameName,
        numPlayers = _ref.numPlayers,
        server = _ref.server;

    classCallCheck(this, Multiplayer);

    this.server = server;
    this.socket = socket;
    this.socketOpts = socketOpts;
    this.gameName = gameName || 'default';
    this.gameID = gameID || 'default';
    this.playerID = playerID || null;
    this.numPlayers = numPlayers || 2;
    this.gameID = this.gameName + ':' + this.gameID;
    this.isConnected = false;
    this.callback = function () {};
  }

  /**
   * Creates a Redux store with some middleware that sends actions
   * to the server whenever they are dispatched.
   * @param {function} reducer - The game reducer.
   * @param {function} enhancer - optional enhancer to apply to Redux store
   */


  createClass(Multiplayer, [{
    key: 'createStore',
    value: function createStore$$1(reducer, enhancer) {
      var _this = this;

      this.store = null;

      // Redux middleware to emit a message on a socket
      // whenever an action is dispatched.
      var SocketEnhancer = redux.applyMiddleware(function (_ref2) {
        var getState = _ref2.getState;
        return function (next) {
          return function (action) {
            var state = getState();
            var result = next(action);

            if (!blacklistedActions.has(action.type) && action._remote != true) {
              _this.socket.emit('action', action, state._stateID, _this.gameID, _this.playerID);
            }

            return result;
          };
        };
      });

      enhancer = enhancer ? redux.compose(enhancer, SocketEnhancer) : SocketEnhancer;
      this.store = redux.createStore(reducer, enhancer);

      return this.store;
    }

    /**
     * Connect to the server.
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (!this.socket) {
        if (this.server) {
          var server = this.server;
          if (server.search(/^https?:\/\//) == -1) {
            server = 'http://' + this.server;
          }

          this.socket = io(server + '/' + this.gameName, this.socketOpts);
        } else {
          this.socket = io('/' + this.gameName, this.socketOpts);
        }
      }

      this.socket.on('sync', function (gameID, state) {
        if (gameID == _this2.gameID && state._stateID >= _this2.store.getState()._stateID) {
          var action = restore(state);
          action._remote = true;
          _this2.store.dispatch(action);
        }
      });

      // Initial sync to get game state.
      this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);

      // Keep track of connection status.
      this.socket.on('connect', function () {
        _this2.isConnected = true;
        _this2.callback();
      });
      this.socket.on('disconnect', function () {
        _this2.isConnected = false;
        _this2.callback();
      });
    }

    /**
     * Subscribe to connection state changes.
     */

  }, {
    key: 'subscribe',
    value: function subscribe(fn) {
      this.callback = fn;
    }

    /**
     * Updates the game id.
     * @param {string} id - The new game id.
     */

  }, {
    key: 'updateGameID',
    value: function updateGameID(id) {
      this.gameID = this.gameName + ':' + id;

      var action = reset();
      action._remote = true;
      this.store.dispatch(action);

      if (this.socket) {
        this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);
      }
    }

    /**
     * Updates the player associated with this client.
     * @param {string} id - The new player id.
     */

  }, {
    key: 'updatePlayerID',
    value: function updatePlayerID(id) {
      this.playerID = id;

      var action = reset();
      action._remote = true;
      this.store.dispatch(action);

      if (this.socket) {
        this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);
      }
    }
  }]);
  return Multiplayer;
}();

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) {
    me.s0 += 1;
  }
  me.s1 -= mash(seed);
  if (me.s1 < 0) {
    me.s1 += 1;
  }
  me.s2 -= mash(seed);
  if (me.s2 < 0) {
    me.s2 += 1;
  }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;
  if (state) {
    if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) == 'object') copy(state, xg);
    prng.state = function () {
      return copy(xg, {});
    };
  }
  return prng;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */
var Random = function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(ctx) {
    classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = ctx._random || { seed: '0' };
  }

  /**
   * Updates ctx with the PRNG state.
   * @param {object} ctx - The ctx object to update.
   */


  createClass(Random, [{
    key: 'update',
    value: function update(ctx) {
      return _extends({}, ctx, { _random: this.state });
    }

    /**
     * Attaches the Random API to ctx.
     * @param {object} ctx - The ctx object to attach to.
     */

  }, {
    key: 'attach',
    value: function attach(ctx) {
      return _extends({}, ctx, { random: this._api() });
    }

    /**
     * Generate a random number.
     */

  }, {
    key: '_random',
    value: function _random() {
      var R = this.state;

      var fn = void 0;
      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, { state: true });
      } else {
        fn = new alea('', { state: R.prngstate });
      }

      var number = fn();

      this.state = _extends({}, R, {
        prngstate: fn.state()
      });

      return number;
    }
  }, {
    key: '_api',
    value: function _api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      };

      // Generate functions for predefined dice values D4 - D20.
      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];
        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _extends({}, predefined, {

        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        }
      });
    }
  }]);
  return Random;
}();

/**
 * Removes the attached Random api from ctx.
 *
 * @param {object} ctx - The ctx object with the Random API attached.
 * @returns {object} A plain ctx object without the Random API.
 */
Random.detach = function (ctx) {
  var random = ctx.random,
      rest = objectWithoutProperties(ctx, ['random']); // eslint-disable-line no-unused-vars

  return rest;
};

/**
 * Generates a new seed from the current date / time.
 */
Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Events
 */
var Events = function () {
  function Events(flow, playerID) {
    classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }

  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  createClass(Events, [{
    key: 'attach',
    value: function attach(ctx) {
      var _this = this;

      var events = {};

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({ key: key, args: args });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _extends({}, ctx, { events: events });
    }

    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: 'update',
    value: function update(state) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.dispatch[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var action = automaticGameEvent(item.key, item.args, this.playerID);
          state = _extends({}, state, this.flow.processGameEvent(state, action));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return state;
    }
  }]);
  return Events;
}();

/**
 * Detaches the Events API from ctx.
 * @param {object} ctx - The ctx object to strip.
 */
Events.detach = function (ctx) {
  var events = ctx.events,
      rest = objectWithoutProperties(ctx, ['events']); // eslint-disable-line no-unused-vars

  return rest;
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 * @param {...object} game - Return value of Game().
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true if we are in a multiplayer client.
 */
function CreateGameReducer(_ref) {
  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      multiplayer = _ref.multiplayer;

  if (!numPlayers) {
    numPlayers = 2;
  }

  var ctx = game.flow.ctx(numPlayers);

  var seed = game.seed;
  if (seed === undefined) {
    seed = Random.seed();
  }
  ctx._random = { seed: seed };

  var random = new Random(ctx);
  var ctxWithAPI = random.attach(ctx);

  var initial = {
    // User managed state.
    G: game.setup(ctxWithAPI),

    // Framework managed state.
    ctx: ctx,

    // A list of actions performed so far. Used by the
    // GameLog to display a journal of moves.
    log: [],

    // List of {G, ctx} pairs that can be undone.
    _undo: [],

    // List of {G, ctx} pairs that can be redone.
    _redo: [],

    // A monotonically non-decreasing ID to ensure that
    // state updates are only allowed from clients that
    // are at the same version that the server.
    _stateID: 0,

    // A snapshot of this object so that actions can be
    // replayed over it to view old snapshots.
    _initial: {}
  };

  var events = new Events(game.flow, ctx.currentPlayer);
  ctxWithAPI = events.attach(ctxWithAPI);

  var state = game.flow.init({ G: initial.G, ctx: ctxWithAPI });

  var _events$update = events.update(state),
      ctxWithEvents = _events$update.ctx;

  initial.G = state.G;
  initial._undo = state._undo;
  initial.ctx = ctxWithEvents;
  initial.ctx = random.update(initial.ctx);
  initial.ctx = Random.detach(initial.ctx);
  initial.ctx = Events.detach(initial.ctx);

  var deepCopy = function deepCopy(obj) {
    return flatted.parse(flatted.stringify(obj));
  };
  initial._initial = deepCopy(initial);

  /**
   * GameReducer
   *
   * Redux reducer that maintains the overall game state.
   * @param {object} state - The state before the action.
   * @param {object} action - A Redux action.
   */
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initial;
    var action = arguments[1];

    switch (action.type) {
      case GAME_EVENT:
        {
          // Process game events only on the server.
          // These events like `endTurn` typically
          // contain code that may rely on secret state
          // and cannot be computed on the client.
          if (multiplayer) {
            return state;
          }

          // Ignore the event if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerCallEvent(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random = new Random(state.ctx);
          // Initialize Events API.
          var _events = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          state = _extends({}, state, { ctx: _random.attach(state.ctx) });
          // Attach Events API to ctx.
          state = _extends({}, state, { ctx: _events.attach(state.ctx) });

          // Update state.
          var newState = game.flow.processGameEvent(state, action);
          // Trigger any events that were called via the Events API.
          newState = _events.update(newState);
          // Update ctx with PRNG state.
          var _ctx = _random.update(newState.ctx);
          // Detach Random API from ctx.
          _ctx = Random.detach(_ctx);
          // Detach Events API from ctx.
          _ctx = Events.detach(_ctx);

          return _extends({}, newState, { ctx: _ctx, _stateID: state._stateID + 1 });
        }

      case MAKE_MOVE:
        {
          // Check whether the game knows the move at all.
          if (!game.moveNames.includes(action.payload.type)) {
            return state;
          }

          // Ignore the move if it isn't allowed at this point.
          if (!game.flow.canMakeMove(state.G, state.ctx, action.payload.type)) {
            return state;
          }

          // Ignore the move if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerMakeMove(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random2 = new Random(state.ctx);
          // Initialize Events API.
          var _events2 = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          var _ctxWithAPI = _random2.attach(state.ctx);
          // Attach Events API to ctx.
          _ctxWithAPI = _events2.attach(_ctxWithAPI);

          // Process the move.
          var G = game.processMove(state.G, action.payload, _ctxWithAPI);
          if (G === undefined) {
            // the game declared the move as invalid.
            return state;
          }

          // Update ctx with PRNG state.
          var _ctx2 = _random2.update(state.ctx);
          // Detach Random API from ctx.
          _ctx2 = Random.detach(_ctx2);
          // Detach Events API from ctx.
          _ctx2 = Events.detach(_ctx2);

          // Undo changes to G if the move should not run on the client.
          if (multiplayer && !game.flow.optimisticUpdate(G, _ctx2, action.payload)) {
            G = state.G;
          }

          var log = [].concat(toConsumableArray(state.log), [action]);
          state = _extends({}, state, { G: G, ctx: _ctx2, log: log, _stateID: state._stateID + 1 });

          // If we're on the client, just process the move
          // and no triggers in multiplayer mode.
          // These will be processed on the server, which
          // will send back a state update.
          if (multiplayer) {
            return state;
          }

          // Allow the flow reducer to process any triggers that happen after moves.
          state = _extends({}, state, { ctx: _random2.attach(state.ctx) });
          state = _extends({}, state, { ctx: _events2.attach(state.ctx) });
          state = game.flow.processMove(state, action.payload);
          state = _events2.update(state);
          state = _extends({}, state, { ctx: _random2.update(state.ctx) });
          state = _extends({}, state, { ctx: Random.detach(state.ctx) });
          state = _extends({}, state, { ctx: Events.detach(state.ctx) });

          return state;
        }

      case RESTORE:
        {
          return action.state;
        }

      case RESET:
        {
          return initial;
        }

      case UNDO:
        {
          var _state = state,
              _undo = _state._undo,
              _redo = _state._redo;


          if (_undo.length < 2) {
            return state;
          }

          var last = _undo[_undo.length - 1];
          var restore = _undo[_undo.length - 2];

          // Only allow undoable moves to be undone.
          if (!game.flow.canUndoMove(state.G, state.ctx, last.moveType)) {
            return state;
          }

          return _extends({}, state, {
            G: restore.G,
            ctx: restore.ctx,
            _undo: _undo.slice(0, _undo.length - 1),
            _redo: [last].concat(toConsumableArray(_redo))
          });
        }

      case REDO:
        {
          var _state2 = state,
              _undo2 = _state2._undo,
              _redo2 = _state2._redo;


          if (_redo2.length == 0) {
            return state;
          }

          var first = _redo2[0];

          return _extends({}, state, {
            G: first.G,
            ctx: first.ctx,
            _undo: [].concat(toConsumableArray(_undo2), [first]),
            _redo: _redo2.slice(1)
          });
        }

      default:
        {
          return state;
        }
    }
  };
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * createDispatchers
 *
 * Create action dispatcher wrappers with bound playerID and credentials
 */
function createDispatchers(storeActionType, innerActionNames, store, playerID, credentials, multiplayer) {
  return innerActionNames.reduce(function (dispatchers, name) {
    dispatchers[name] = function () {
      var assumedPlayerID = playerID;

      // In singleplayer mode, if the client does not have a playerID
      // associated with it, we attach the currentPlayer as playerID.
      if (!multiplayer && (playerID === null || playerID === undefined)) {
        var state = store.getState();
        assumedPlayerID = state.ctx.currentPlayer;
      }

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      store.dispatch(ActionCreators[storeActionType](name, args, assumedPlayerID, credentials));
    };
    return dispatchers;
  }, {});
}

/**
 * createEventDispatchers
 *
 * Creates a set of dispatchers to dispatch game flow events.
 * @param {Array} eventNames - A list of event names.
 * @param {object} store - The Redux store to create dispatchers for.
 * @param {string} playerID - The ID of the player dispatching these events.
 * @param {string} credentials - A key indicating that the player is authorized to play.
 */
var createEventDispatchers = createDispatchers.bind(null, 'gameEvent');

/**
 * createMoveDispatchers
 *
 * Creates a set of dispatchers to make moves.
 * @param {Array} moveNames - A list of move names.
 * @param {object} store - The Redux store to create dispatchers for.
 * @param {string} playerID - The ID of the player dispatching these events.
 * @param {string} credentials - A key indicating that the player is authorized to play.
 */
var createMoveDispatchers = createDispatchers.bind(null, 'makeMove');

/**
 * Implementation of Client (see below).
 */

var _ClientImpl = function () {
  function _ClientImpl(_ref) {
    var _this = this;

    var game = _ref.game,
        ai = _ref.ai,
        numPlayers = _ref.numPlayers,
        multiplayer = _ref.multiplayer,
        socketOpts = _ref.socketOpts,
        gameID = _ref.gameID,
        playerID = _ref.playerID,
        credentials = _ref.credentials,
        enhancer = _ref.enhancer;
    classCallCheck(this, _ClientImpl);

    this.game = game;
    this.playerID = playerID;
    this.gameID = gameID;
    this.credentials = credentials;

    var server = undefined;
    if (multiplayer instanceof Object && 'server' in multiplayer) {
      server = multiplayer.server;
      multiplayer = true;
    }

    this.multiplayer = multiplayer;

    this.reducer = CreateGameReducer({
      game: game,
      numPlayers: numPlayers,
      multiplayer: multiplayer
    });

    if (ai !== undefined && multiplayer === undefined) {
      var bot = new ai.bot({ game: game, enumerate: ai.enumerate });

      this.step = function () {
        var state = _this.store.getState();
        var playerID = state.ctx.actionPlayers[0];

        var _bot$play = bot.play(state, playerID),
            action = _bot$play.action,
            metadata = _bot$play.metadata;

        if (action) {
          action.payload.metadata = metadata;
          _this.store.dispatch(action);
        }

        return action;
      };
    }

    this.reset = function () {
      _this.store.dispatch(reset());
    };
    this.undo = function () {
      _this.store.dispatch(undo());
    };
    this.redo = function () {
      _this.store.dispatch(redo());
    };

    this.store = null;

    if (multiplayer) {
      this.multiplayerClient = new Multiplayer({
        gameID: gameID,
        playerID: playerID,
        gameName: game.name,
        numPlayers: numPlayers,
        server: server,
        socketOpts: socketOpts
      });
      this.store = this.multiplayerClient.createStore(this.reducer, enhancer);
    } else {
      this.store = redux.createStore(this.reducer, enhancer);

      // If no playerID was provided, set it to undefined.
      if (this.playerID === null) {
        this.playerID = undefined;
      }
    }

    this.createDispatchers();
  }

  createClass(_ClientImpl, [{
    key: 'subscribe',
    value: function subscribe(fn) {
      this.store.subscribe(fn);

      if (this.multiplayerClient) {
        this.multiplayerClient.subscribe(fn);
      }
    }
  }, {
    key: 'getState',
    value: function getState() {
      var state = this.store.getState();

      // isActive.

      var isActive = true;

      var canPlayerMakeMove = this.game.flow.canPlayerMakeMove(state.G, state.ctx, this.playerID);

      if (this.multiplayer && !canPlayerMakeMove) {
        isActive = false;
      }

      if (!this.multiplayer && this.playerID !== null && this.playerID !== undefined && !canPlayerMakeMove) {
        isActive = false;
      }

      if (state.ctx.gameover !== undefined) {
        isActive = false;
      }

      // Secrets are normally stripped on the server,
      // but we also strip them here so that game developers
      // can see their effects while prototyping.
      var G = this.game.playerView(state.G, state.ctx, this.playerID);

      // Combine into return value.
      var ret = _extends({}, state, { isActive: isActive, G: G });

      if (this.multiplayerClient) {
        var isConnected = this.multiplayerClient.isConnected;
        ret = _extends({}, ret, { isConnected: isConnected });
      }

      return ret;
    }
  }, {
    key: 'connect',
    value: function connect() {
      if (this.multiplayerClient) {
        this.multiplayerClient.connect();
      }
    }
  }, {
    key: 'createDispatchers',
    value: function createDispatchers() {
      this.moves = createMoveDispatchers(this.game.moveNames, this.store, this.playerID, this.credentials, this.multiplayer);

      this.events = createEventDispatchers(this.game.flow.eventNames, this.store, this.playerID, this.credentials, this.multiplayer);
    }
  }, {
    key: 'updatePlayerID',
    value: function updatePlayerID(playerID) {
      this.playerID = playerID;
      this.createDispatchers();

      if (this.multiplayerClient) {
        this.multiplayerClient.updatePlayerID(playerID);
      }
    }
  }, {
    key: 'updateGameID',
    value: function updateGameID(gameID) {
      this.gameID = gameID;
      this.createDispatchers();

      if (this.multiplayerClient) {
        this.multiplayerClient.updateGameID(gameID);
      }
    }
  }, {
    key: 'updateCredentials',
    value: function updateCredentials(credentials) {
      this.credentials = credentials;
      this.createDispatchers();
    }
  }]);
  return _ClientImpl;
}();

/**
 * Client
 *
 * boardgame.io JS client.
 *
 * @param {...object} game - The return value of `Game`.
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }
 *                                  to make a multiplayer client. The second
 *                                  syntax specifies a non-default socket server.
 * @param {...object} socketOpts - Options to pass to socket.io.
 * @param {...object} gameID - The gameID that you want to connect to.
 * @param {...object} playerID - The playerID associated with this client.
 * @param {...string} credentials - The authentication credentials associated with this client.
 *
 * Returns:
 *   A JS object that provides an API to interact with the
 *   game by dispatching moves and events.
 */


function Client(opts) {
  return new _ClientImpl(opts);
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

function AssignShortcuts(moveNames, eventNames, blacklist) {
  var shortcuts = {};

  var events = {};
  for (var name in moveNames) {
    events[name] = name;
  }
  for (var _name in eventNames) {
    events[_name] = _name;
  }

  var taken = {};
  for (var i = 0; i < blacklist.length; i++) {
    var c = blacklist[i];
    taken[c] = true;
  }

  // Try assigning the first char of each move as the shortcut.
  var t = taken;
  var canUseFirstChar = true;
  for (var _name2 in events) {
    var shortcut = _name2[0];
    if (t[shortcut]) {
      canUseFirstChar = false;
      break;
    }

    t[shortcut] = true;
    shortcuts[_name2] = shortcut;
  }
  if (canUseFirstChar) {
    return shortcuts;
  }

  // If those aren't unique, use a-z.
  t = taken;
  var next = 97;
  shortcuts = {};
  for (var _name3 in events) {
    var _shortcut = String.fromCharCode(next);

    while (t[_shortcut]) {
      next++;
      _shortcut = String.fromCharCode(next);
    }

    t[_shortcut] = true;
    shortcuts[_name3] = _shortcut;
  }
  return shortcuts;
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var Item = function Item(props) {
  return React.createElement(
    'div',
    { className: 'gameinfo-item' },
    React.createElement(
      'strong',
      null,
      props.name,
      ' '
    ),
    React.createElement(
      'div',
      null,
      JSON.stringify(props.value)
    )
  );
};

Item.propTypes = {
  name: PropTypes.string.isRequired,
  value: PropTypes.any
};

var GameInfo = function GameInfo(props) {
  return React.createElement(
    'section',
    { className: 'gameinfo' },
    React.createElement(Item, { name: 'gameID', value: props.gameID }),
    React.createElement(Item, { name: 'playerID', value: props.playerID }),
    React.createElement(Item, { name: 'isActive', value: props.isActive }),
    props.isMultiplayer && React.createElement(
      'span',
      null,
      React.createElement(Item, { name: 'isConnected', value: props.isConnected }),
      React.createElement(Item, { name: 'isMultiplayer', value: props.isMultiplayer })
    )
  );
};

GameInfo.propTypes = {
  gameID: PropTypes.string,
  playerID: PropTypes.string,
  isActive: PropTypes.bool,
  isConnected: PropTypes.bool,
  isMultiplayer: PropTypes.bool
};

__$styleInject("/*\n * Copyright 2017 The boardgame.io Authors\n *\n * Use of this source code is governed by a MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\n\n.debug-ui {\n  text-align: left;\n  overflow-x: hidden;\n  overflow-y: scroll;\n  background: #fefefe;\n  border-left: 1px solid #ddd;\n  box-shadow: -1px 0 10px #aaa;\n  position: absolute;\n  width: 300px;\n  right: 0;\n  top: 0;\n  height: 100%;\n  font-family: monospace;\n  font-size: 14px;\n}\n\n#debug-controls.docktop {\n  position: fixed;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-evenly;\n  align-items: center;\n  padding-left: 10px;\n  padding-right: 10px;\n  min-width: 500px;\n  top: 0;\n  right: 300px;\n  height: 50px;\n  background: #fff;\n  box-shadow: -3px 3px 3px #ccc;\n}\n\n@media only screen and (max-device-width: 750px) {\n  .debug-ui {\n    display: none;\n  }\n}\n\n.debug-ui .gameinfo {\n  background: #ddd;\n  position: fixed;\n  bottom: 0;\n  box-sizing: border-box;\n  width: 285px;\n  margin-left: -20px;\n  margin-bottom: 0;\n  padding: 10px;\n}\n\n.debug-ui .gameinfo-item div {\n  float: right;\n  text-align: right;\n}\n\n.debug-ui .ai-visualization {\n  position: fixed;\n  opacity: 100%;\n  right: 300px;\n  height: 100%;\n  width: 100%;\n  max-width: 3000px;\n  background: #fafafa;\n  border-right: 1px solid #ddd;\n}\n\n.debug-ui .pane {\n  float: left;\n  padding: 20px;\n  box-sizing: border-box;\n  min-width: 300px;\n  max-width: 400px;\n  opacity: 0.8;\n}\n\n.debug-ui section {\n  margin-bottom: 20px;\n}\n\n.debug-ui textarea {\n  resize: none;\n}\n\n.debug-ui .move {\n  cursor: pointer;\n  margin-bottom: 10px;\n  color: #666;\n}\n\n.debug-ui .move:hover {\n  color: #333;\n}\n\n.debug-ui .move.active {\n  color: #111;\n  font-weight: bold;\n}\n\n.debug-ui .move-error {\n  color: #a00;\n  font-weight: bold;\n}\n\n.debug-ui .arg-field {\n  outline: none;\n  font-family: monospace;\n}\n\n.debug-ui .key {\n  margin-bottom: 5px;\n}\n\n.debug-ui .key-box {\n  display: inline-block;\n  cursor: pointer;\n  min-width: 10px;\n  padding-left: 5px;\n  padding-right: 5px;\n  height: 20px;\n  line-height: 20px;\n  text-align: center;\n  border: 1px solid #ccc;\n  box-shadow: 1px 1px 1px #888;\n  background: #eee;\n  color: #444;\n}\n\n.debug-ui .key-box:hover {\n  background: #ddd;\n}\n\n.debug-ui .key.active .key-box {\n  background: #ddd;\n  border: 1px solid #999;\n  box-shadow: none;\n}\n\n.debug-ui .key-child {\n  display: inline-block;\n  height: 20px;\n  margin-left: 10px;\n}\n\n.debug-ui .menu {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n}\n\n.debug-ui .menu .item {\n  cursor: pointer;\n  margin-top: -10px;\n  margin-bottom: 20px;\n  margin-right: 10px;\n  padding: 5px;\n  min-width: 50px;\n  text-align: center;\n}\n\n.debug-ui .menu .item.active {\n  font-weight: bold;\n  border-bottom: 3px solid #ccc;\n}\n\n.debug-ui .player-box {\n  display: flex;\n  flex-direction: row;\n}\n\n.debug-ui .player {\n  cursor: pointer;\n  text-align: center;\n  width: 30px;\n  height: 30px;\n  line-height: 30px;\n  background: #eee;\n  border: 3px solid #fff;\n  box-sizing: content-box;\n}\n\n.debug-ui .player.current {\n  background: #555;\n  color: #eee;\n  font-weight: bold;\n}\n\n.debug-ui .player.active {\n  border: 3px solid #ff7f50;\n}\n", undefined);

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * KeyboardShortcut
 *
 * Registers a keyboard shortcut to activate the
 * associated child component that is passed in.
 *
 * When the key is pressed, 'active' is set to true
 * in the prop passed to the child.
 */
var KeyboardShortcut = function (_React$Component) {
  inherits(KeyboardShortcut, _React$Component);

  function KeyboardShortcut() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, KeyboardShortcut);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = KeyboardShortcut.__proto__ || Object.getPrototypeOf(KeyboardShortcut)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      active: false
    }, _this.deactivate = function () {
      _this.setState({ active: false });
    }, _this.activate = function () {
      _this.setState({ active: true });
      if (_this.props.onPress) {
        _this.props.onPress();
        _this.setState({ active: false });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(KeyboardShortcut, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      Mousetrap.bind(this.props.value, function (e) {
        e.preventDefault();
        _this2.activate();
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      Mousetrap.unbind(this.props.value);
    }
  }, {
    key: 'render',
    value: function render() {
      var child = this.props.children;
      if (_typeof(this.props.children) === _typeof(this)) {
        child = React.cloneElement(this.props.children, {
          active: this.state.active,
          deactivate: this.deactivate,
          activate: this.activate
        });
      }

      var className = 'key';
      if (this.state.active) {
        className += ' active';
      }

      return React.createElement(
        'div',
        { className: className },
        React.createElement(
          'div',
          { className: 'key-box', onClick: this.activate },
          this.props.value
        ),
        React.createElement(
          'div',
          { className: 'key-child' },
          child
        )
      );
    }
  }]);
  return KeyboardShortcut;
}(React.Component);
KeyboardShortcut.propTypes = {
  value: PropTypes.string.isRequired,
  children: PropTypes.any,
  onPress: PropTypes.func
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Controls that are triggered by keyboard shortcuts.
 */
var Controls = function Controls(props) {
  var ai = null;

  if (props.step) {
    ai = [React.createElement(
      KeyboardShortcut,
      { key: '4', value: '4', onPress: props.step },
      'step'
    ), React.createElement(
      KeyboardShortcut,
      { key: '5', value: '5', onPress: props.simulate },
      'simulate'
    )];
  }

  var style = null;
  var className = 'controls';
  if (props.dockTop) {
    className += ' docktop';
  }
  if (props.help) {
    className += ' help';
  }

  var display = props.help && !props.dockTop ? 'block' : 'none';

  return React.createElement(
    'section',
    { id: 'debug-controls', style: style, className: className },
    React.createElement(
      KeyboardShortcut,
      { value: '1', onPress: props.reset },
      'reset'
    ),
    React.createElement(
      KeyboardShortcut,
      { value: '2', onPress: props.save },
      'save'
    ),
    React.createElement(
      KeyboardShortcut,
      { value: '3', onPress: props.restore },
      'restore'
    ),
    ai,
    props.dockTop || React.createElement(
      KeyboardShortcut,
      { value: '?', onPress: props.toggleHelp },
      'show more'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        'd'
      ),
      ' show/hide this pane'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        'l'
      ),
      ' show/hide log'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        'i'
      ),
      ' show/hide game info tab'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        't'
      ),
      ' dock controls'
    )
  );
};

Controls.propTypes = {
  help: PropTypes.bool,
  toggleHelp: PropTypes.func,
  step: PropTypes.func,
  simulate: PropTypes.func,
  reset: PropTypes.func,
  save: PropTypes.func,
  restore: PropTypes.func,
  dockTop: PropTypes.bool
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Component that renders information about the
 * players in the game (whose turn it is etc.).
 */
var PlayerInfo = function (_React$Component) {
  inherits(PlayerInfo, _React$Component);

  function PlayerInfo() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, PlayerInfo);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = PlayerInfo.__proto__ || Object.getPrototypeOf(PlayerInfo)).call.apply(_ref, [this].concat(args))), _this), _this.onClick = function (playerID) {
      var arg = playerID == _this.props.playerID ? null : playerID;
      _this.props.onClick(arg);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(PlayerInfo, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var players = [];

      var _loop = function _loop(i) {
        var playerID = i + '';

        var className = 'player';

        if (playerID === _this2.props.ctx.currentPlayer) {
          className += ' current';
        }

        if (playerID === _this2.props.playerID) {
          className += ' active';
        }

        players.push(React.createElement(
          'div',
          {
            className: className,
            key: i,
            onClick: function onClick() {
              return _this2.onClick(playerID);
            }
          },
          playerID
        ));
      };

      for (var i = 0; i < this.props.ctx.numPlayers; i++) {
        _loop(i);
      }

      return React.createElement(
        'div',
        { className: 'player-box' },
        players
      );
    }
  }]);
  return PlayerInfo;
}(React.Component);
PlayerInfo.propTypes = {
  ctx: PropTypes.any.isRequired,
  playerID: PropTypes.any,
  onClick: PropTypes.func
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * DebugMove
 *
 * Component that allows the user to dispatch a move from
 * the debug pane. The user is presented with the textarea
 * to enter any additional arguments.
 */
var DebugMove = function (_React$Component) {
  inherits(DebugMove, _React$Component);

  function DebugMove() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, DebugMove);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DebugMove.__proto__ || Object.getPrototypeOf(DebugMove)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      error: ''
    }, _this.onSubmit = function (value) {
      var error = '';

      try {
        var argArray = new Function('return [' + value + ']')();
        _this.props.fn.apply(_this, argArray);
      } catch (e) {
        error = '' + e;
      }

      _this.setState({
        error: error,
        focus: false,
        enterArg: false
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(DebugMove, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        null,
        React.createElement(
          KeyboardShortcut,
          { value: this.props.shortcut },
          React.createElement(DebugMoveArgField, { name: this.props.name, onSubmit: this.onSubmit })
        ),
        this.state.error ? React.createElement(
          'span',
          { className: 'move-error' },
          this.state.error
        ) : null
      );
    }
  }]);
  return DebugMove;
}(React.Component);

DebugMove.propTypes = {
  name: PropTypes.string.isRequired,
  shortcut: PropTypes.string.isRequired,
  fn: PropTypes.func.isRequired
};
var DebugMoveArgField = function (_React$Component2) {
  inherits(DebugMoveArgField, _React$Component2);

  function DebugMoveArgField() {
    var _ref2;

    var _temp2, _this2, _ret2;

    classCallCheck(this, DebugMoveArgField);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _ret2 = (_temp2 = (_this2 = possibleConstructorReturn(this, (_ref2 = DebugMoveArgField.__proto__ || Object.getPrototypeOf(DebugMoveArgField)).call.apply(_ref2, [this].concat(args))), _this2), _this2.onKeyDown = function (e) {
      if (e.key == 'Enter') {
        e.preventDefault();
        var value = _this2.span.innerText;
        _this2.props.onSubmit(value);
        _this2.span.innerText = '';
        _this2.props.deactivate();
      }

      if (e.key == 'Escape') {
        e.preventDefault();
        _this2.props.deactivate();
      }
    }, _temp2), possibleConstructorReturn(_this2, _ret2);
  }

  createClass(DebugMoveArgField, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.active) {
        this.span.focus();
      } else {
        this.span.blur();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var className = 'move';
      if (this.props.active) className += ' active';
      return React.createElement(
        'div',
        { className: className, onClick: this.props.activate },
        this.props.name,
        '(',
        React.createElement('span', {
          ref: function ref(r) {
            _this3.span = r;
          },
          className: 'arg-field',
          onBlur: this.props.deactivate,
          onKeyDown: this.onKeyDown,
          contentEditable: true
        }),
        ')'
      );
    }
  }]);
  return DebugMoveArgField;
}(React.Component);
DebugMoveArgField.propTypes = {
  name: PropTypes.string.isRequired,
  onSubmit: PropTypes.func.isRequired,
  active: PropTypes.bool,
  activate: PropTypes.func,
  deactivate: PropTypes.func
};

__$styleInject("/*\n * Copyright 2017 The boardgame.io Authors\n *\n * Use of this source code is governed by a MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\n\n.gamelog {\n  display: grid;\n  grid-template-columns: 30px 1fr 30px;\n  :grid-auto-rows: auto;\n  grid-auto-flow: column;\n}\n\n.gamelog .turn-marker {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  grid-column: 1;\n  background: #555;\n  color: #eee;\n  text-align: center;\n  font-weight: bold;\n  border: 1px solid #888;\n}\n\n.gamelog .log-event {\n  grid-column: 2;\n  cursor: pointer;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  background: #fff;\n  border: 1px dotted #ccc;\n  border-left: 5px solid #ccc;\n  padding: 5px;\n  text-align: center;\n  color: #888;\n  font-size: 14px;\n  height: 25px;\n  line-height: 25px;\n}\n\n.gamelog .phase-marker {\n  grid-column: 3;\n  background: #555;\n  border: 1px solid #888;\n  color: #eee;\n  text-align: center;\n  font-weight: bold;\n  padding-top: 10px;\n  padding-bottom: 10px;\n  text-orientation: sideways;\n  writing-mode: vertical-rl;\n  line-height: 30px;\n}\n\n.gamelog.pinned .log-event {\n  opacity: 0.2;\n}\n\n.gamelog .log-event:hover {\n  border-style: solid;\n  background: #eee;\n}\n\n.gamelog .log-event.pinned {\n  border-style: solid;\n  background: #eee;\n  opacity: 1;\n}\n\n.gamelog div.player0 {\n  border-left-color: #ff851b;\n}\n\n.gamelog div.player1 {\n  border-left-color: #7fdbff;\n}\n\n.gamelog div.player2 {\n  border-left-color: #0074d9;\n}\n\n.gamelog div.player3 {\n  border-left-color: #39cccc;\n}\n\n.gamelog div.player4 {\n  border-left-color: #3d9970;\n}\n\n.gamelog div.player5 {\n  border-left-color: #2ecc40;\n}\n\n.gamelog div.player6 {\n  border-left-color: #01ff70;\n}\n\n.gamelog div.player7 {\n  border-left-color: #ffdc00;\n}\n\n.gamelog div.player8 {\n  border-left-color: #001f3f;\n}\n\n.gamelog div.player9 {\n  border-left-color: #ff4136;\n}\n\n.gamelog div.player10 {\n  border-left-color: #85144b;\n}\n\n.gamelog div.player11 {\n  border-left-color: #f012be;\n}\n\n.gamelog div.player12 {\n  border-left-color: #b10dc9;\n}\n\n.gamelog div.player13 {\n  border-left-color: #111111;\n}\n\n.gamelog div.player14 {\n  border-left-color: #aaaaaa;\n}\n\n.gamelog div.player15 {\n  border-left-color: #dddddd;\n}\n", undefined);

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * LogEvent
 *
 * Logs a single action in the game.
 */
var LogEvent = function LogEvent(props) {
  var action = props.action;
  var args = action.payload.args || [];
  var playerID = action.payload.playerID;
  var classNames = 'log-event player' + playerID;

  if (props.pinned) {
    classNames += ' pinned';
  }

  return React.createElement(
    'div',
    {
      className: classNames,
      onClick: function onClick() {
        return props.onLogClick(props.logIndex);
      },
      onMouseEnter: function onMouseEnter() {
        return props.onMouseEnter(props.logIndex);
      },
      onMouseLeave: function onMouseLeave() {
        return props.onMouseLeave();
      }
    },
    action.payload.type,
    '(',
    args.join(','),
    ')'
  );
};

LogEvent.propTypes = {
  action: PropTypes.any.isRequired,
  logIndex: PropTypes.number.isRequired,
  onLogClick: PropTypes.func.isRequired,
  onMouseEnter: PropTypes.func.isRequired,
  onMouseLeave: PropTypes.func.isRequired,
  pinned: PropTypes.bool
};

/**
 * TurnMarker
 *
 * The markers on the left of the log events that indicate
 * which turn the event belongs to.
 */
var TurnMarker = function TurnMarker(props) {
  return React.createElement(
    'div',
    { className: 'turn-marker', style: { gridRow: 'span ' + props.numEvents } },
    props.turn
  );
};

TurnMarker.propTypes = {
  turn: PropTypes.number.isRequired,
  numEvents: PropTypes.number.isRequired
};

/**
 * PhaseMarker
 *
 * The markers on the right of the log events that indicate
 * which phase the event belongs to.
 */
var PhaseMarker = function PhaseMarker(props) {
  return React.createElement(
    'div',
    {
      className: 'phase-marker',
      style: { gridRow: 'span ' + props.numEvents }
    },
    props.phase
  );
};

PhaseMarker.propTypes = {
  phase: PropTypes.string.isRequired,
  numEvents: PropTypes.number.isRequired
};

/**
 * GameLog
 *
 * Component to log the actions in the game.
 */
var GameLog = function (_React$Component) {
  inherits(GameLog, _React$Component);

  function GameLog() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, GameLog);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GameLog.__proto__ || Object.getPrototypeOf(GameLog)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      pinned: null
    }, _this.rewind = function (logIndex) {
      var state = _this.props.initialState;
      for (var i = 0; i <= logIndex; i++) {
        var action = _this.props.log[i];
        if (!action.automatic) {
          state = _this.props.reducer(state, action);
        }
      }
      return { G: state.G, ctx: state.ctx };
    }, _this.onLogClick = function (logIndex) {
      _this.setState(function (o) {
        var state = _this.rewind(logIndex);
        var metadata = _this.props.log[logIndex].payload.metadata;

        if (o.pinned === logIndex) {
          _this.props.onHover({ logIndex: logIndex, state: state, metadata: undefined });
          return { pinned: null };
        }

        _this.props.onHover({ logIndex: logIndex, state: state, metadata: metadata });
        return { pinned: logIndex };
      });
    }, _this.onMouseEnter = function (logIndex) {
      if (_this.state.pinned === null) {
        var state = _this.rewind(logIndex);
        _this.props.onHover({ logIndex: logIndex, state: state });
      }
    }, _this.onMouseLeave = function () {
      if (_this.state.pinned === null) {
        _this.props.onHover({ state: null });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(GameLog, [{
    key: 'render',
    value: function render() {
      var log = [];
      var turns = [];
      var phases = [];
      var eventsInCurrentPhase = 0;
      var eventsInCurrentTurn = 0;
      var state = this.props.initialState;

      var lastAction = 0;
      for (var i = 0; i < this.props.log.length; i++) {
        var action = this.props.log[i];
        if (action.type == MAKE_MOVE || !action.automatic) {
          lastAction = i;
        }
      }

      for (var _i = 0; _i < this.props.log.length; _i++) {
        var _action = this.props.log[_i];
        var oldTurn = state.ctx.turn;
        var oldPhase = state.ctx.phase;

        if (_action.type == MAKE_MOVE) {
          log.push(React.createElement(LogEvent, {
            key: _i,
            pinned: _i === this.state.pinned,
            logIndex: _i,
            onLogClick: this.onLogClick,
            onMouseEnter: this.onMouseEnter,
            onMouseLeave: this.onMouseLeave,
            action: _action
          }));

          eventsInCurrentTurn++;
          eventsInCurrentPhase++;
        }

        if (!_action.automatic) {
          state = this.props.reducer(state, _action);

          if (state.ctx.turn != oldTurn || state.ctx.gameover !== undefined || _i == lastAction) {
            turns.push(React.createElement(TurnMarker, {
              key: turns.length,
              turn: oldTurn,
              numEvents: eventsInCurrentTurn
            }));
            eventsInCurrentTurn = 0;
          }

          if (state.ctx.phase != oldPhase || state.ctx.gameover !== undefined || _i == lastAction) {
            phases.push(React.createElement(PhaseMarker, {
              key: phases.length,
              phase: oldPhase,
              numEvents: eventsInCurrentPhase
            }));
            eventsInCurrentPhase = 0;
          }
        }
      }

      var className = 'gamelog';
      if (this.state.pinned !== null) {
        className += ' pinned';
      }

      return React.createElement(
        'div',
        { className: className },
        turns,
        log,
        phases
      );
    }
  }]);
  return GameLog;
}(React.Component);
GameLog.propTypes = {
  onHover: PropTypes.func,
  reducer: PropTypes.func,
  initialState: PropTypes.any.isRequired,
  log: PropTypes.array.isRequired
};
GameLog.defaultProps = {
  onHover: function onHover() {}
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Removes all the keys in ctx that begin with a _.
 */
function SanitizeCtx(ctx) {
  var r = {};
  for (var key in ctx) {
    if (!key.startsWith('_')) {
      r[key] = ctx[key];
    }
  }
  return r;
}

/**
 * Debug
 *
 * Debug pane that displays the game state objects,
 * allows you to dispatch moves,
 * and allows you to save / restore from localStorage.
 */
var Debug = function (_React$Component) {
  inherits(Debug, _React$Component);

  function Debug(props) {
    classCallCheck(this, Debug);

    var _this = possibleConstructorReturn(this, (Debug.__proto__ || Object.getPrototypeOf(Debug)).call(this, props));

    _this.saveState = function () {
      var json = flatted.stringify(_this.props.gamestate);
      window.localStorage.setItem('gamestate', json);
    };

    _this.restoreState = function () {
      var gamestateJSON = window.localStorage.getItem('gamestate');
      if (gamestateJSON !== null) {
        var gamestate = flatted.parse(gamestateJSON);
        _this.props.store.dispatch(restore(gamestate));
      }
    };

    _this.onClickMain = function () {
      _this.setState({ showLog: false });
    };

    _this.onClickLog = function () {
      _this.setState({ showLog: true });
    };

    _this.toggleHelp = function () {
      _this.setState(function (oldstate) {
        return { help: !oldstate.help };
      });
    };

    _this.onLogHover = function (_ref) {
      var state = _ref.state,
          metadata = _ref.metadata;

      _this.setState({ AIMetadata: metadata });
      _this.props.overrideGameState(state);
    };

    _this.simulate = function () {
      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10000;
      var sleepTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

      var step = function step() {
        var action = _this.props.step();
        if (action && iterations > 1) {
          iterations--;
          setTimeout(step, sleepTimeout);
        }
      };

      step();
    };

    _this.shortcuts = AssignShortcuts(props.moves, props.events, 'dlit');

    _this.state = {
      showDebugUI: true,
      showLog: false,
      showGameInfo: props.showGameInfo,
      dockControls: props.dockControls,
      help: false,
      AIMetadata: null
    };
    return _this;
  }

  createClass(Debug, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      Mousetrap.bind('d', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { showDebugUI: !old.showDebugUI };
        });
      });

      Mousetrap.bind('l', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { showLog: !old.showLog };
        });
      });

      Mousetrap.bind('i', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { showGameInfo: !old.showGameInfo };
        });
      });

      Mousetrap.bind('t', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { dockControls: !old.dockControls };
        });
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      Mousetrap.unbind('d');
      Mousetrap.unbind('l');
    }
  }, {
    key: 'render',
    value: function render() {
      if (!this.state.showDebugUI) {
        return null;
      }

      var moves = [];
      for (var name in this.props.moves) {
        var fn = this.props.moves[name];
        var shortcut = this.shortcuts[name];
        moves.push(React.createElement(DebugMove, { key: name, name: name, fn: fn, shortcut: shortcut }));
      }

      var events = [];
      for (var _name in this.props.events) {
        var _fn = this.props.events[_name];
        var _shortcut = this.shortcuts[_name];
        events.push(React.createElement(DebugMove, { key: _name, name: _name, fn: _fn, shortcut: _shortcut }));
      }

      var visualizeAI = this.state.AIMetadata && this.props.visualizeAI;
      var className = 'debug-ui';

      if (this.state.dockControls) {
        className += ' docktop';
      }

      return React.createElement(
        'div',
        { className: className },
        visualizeAI && React.createElement(
          'div',
          { className: 'ai-visualization' },
          this.props.visualizeAI(this.state.AIMetadata)
        ),
        React.createElement(
          'div',
          { className: 'pane' },
          React.createElement(
            'div',
            { className: 'menu' },
            React.createElement(
              'div',
              {
                className: this.state.showLog ? 'item' : 'item active',
                onClick: this.onClickMain
              },
              'Main'
            ),
            React.createElement(
              'div',
              {
                className: this.state.showLog ? 'item active' : 'item',
                onClick: this.onClickLog
              },
              'Log'
            )
          ),
          this.state.showLog || React.createElement(
            'span',
            null,
            this.state.showGameInfo && React.createElement(GameInfo, {
              gameID: this.props.gameID,
              playerID: this.props.playerID,
              isActive: this.props.gamestate.isActive,
              isConnected: this.props.gamestate.isConnected,
              isMultiplayer: this.props.isMultiplayer
            }),
            React.createElement(Controls, {
              dockTop: this.state.dockControls,
              help: this.state.help,
              toggleHelp: this.toggleHelp,
              step: this.props.step,
              simulate: this.simulate,
              reset: this.props.reset,
              save: this.saveState,
              restore: this.restoreState
            }),
            React.createElement(
              'h3',
              null,
              'Players'
            ),
            React.createElement(PlayerInfo, {
              ctx: this.props.gamestate.ctx,
              playerID: this.props.playerID,
              onClick: this.props.updatePlayerID
            }),
            React.createElement(
              'h3',
              null,
              'Moves'
            ),
            React.createElement(
              'section',
              null,
              moves
            ),
            React.createElement(
              'h3',
              null,
              'Events'
            ),
            React.createElement(
              'section',
              null,
              events
            ),
            React.createElement(
              'section',
              null,
              React.createElement(
                'pre',
                { className: 'json' },
                React.createElement(
                  'strong',
                  null,
                  'G'
                ),
                ':',
                ' ',
                JSON.stringify(this.props.gamestate.G, null, 2)
              )
            ),
            React.createElement(
              'section',
              null,
              React.createElement(
                'pre',
                { className: 'json' },
                React.createElement(
                  'strong',
                  null,
                  'ctx'
                ),
                ':',
                ' ',
                JSON.stringify(SanitizeCtx(this.props.gamestate.ctx), null, 2)
              )
            )
          ),
          this.state.showLog && React.createElement(
            'section',
            null,
            React.createElement(GameLog, {
              onHover: this.onLogHover,
              reducer: this.props.reducer,
              log: this.props.gamestate.log,
              initialState: this.props.gamestate._initial
            })
          )
        )
      );
    }
  }]);
  return Debug;
}(React.Component);
Debug.propTypes = {
  gamestate: PropTypes.shape({
    G: PropTypes.any.isRequired,
    ctx: PropTypes.any.isRequired,
    log: PropTypes.array.isRequired,
    isActive: PropTypes.bool,
    isConnected: PropTypes.bool,
    _initial: PropTypes.any.isRequired
  }),
  gameID: PropTypes.string.isRequired,
  playerID: PropTypes.string,
  isMultiplayer: PropTypes.bool,
  moves: PropTypes.any,
  events: PropTypes.any,
  restore: PropTypes.func,
  showLog: PropTypes.bool,
  store: PropTypes.any,
  step: PropTypes.func,
  reset: PropTypes.func,
  reducer: PropTypes.func,
  overrideGameState: PropTypes.func,
  visualizeAI: PropTypes.func,
  updateGameID: PropTypes.func,
  updatePlayerID: PropTypes.func,
  updateCredentials: PropTypes.func,
  showGameInfo: PropTypes.bool,
  dockControls: PropTypes.bool
};
Debug.defaultProps = {
  showGameInfo: true,
  dockControls: false
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Client
 *
 * boardgame.io React client.
 *
 * @param {...object} game - The return value of `Game`.
 * @param {...object} numPlayers - The number of players.
 * @param {...object} board - The React component for the game.
 * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }
 *                                  to make a multiplayer client. The second
 *                                  syntax specifies a non-default socket server.
 * @param {...object} debug - Enables the Debug UI.
 * @param {...object} enhancer - Optional enhancer to send to the Redux store
 *
 * Returns:
 *   A React component that wraps board and provides an
 *   API through props for it to interact with the framework
 *   and dispatch actions such as MAKE_MOVE, GAME_EVENT, RESET,
 *   UNDO and REDO.
 */
function Client$1(_ref) {
  var _class, _temp;

  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      board = _ref.board,
      multiplayer = _ref.multiplayer,
      ai = _ref.ai,
      debug = _ref.debug,
      enhancer = _ref.enhancer;

  if (debug === undefined) debug = true;

  /*
   * WrappedBoard
   *
   * The main React component that wraps the passed in
   * board component and adds the API to its props.
   */
  return _temp = _class = function (_React$Component) {
    inherits(WrappedBoard, _React$Component);

    function WrappedBoard(props) {
      classCallCheck(this, WrappedBoard);

      var _this = possibleConstructorReturn(this, (WrappedBoard.__proto__ || Object.getPrototypeOf(WrappedBoard)).call(this, props));

      _this.state = {
        gameStateOverride: null
      };

      _this.updateGameID = function (gameID) {
        _this.client.updateGameID(gameID);
        _this.gameID = gameID;
        _this.forceUpdate();
      };

      _this.updatePlayerID = function (playerID) {
        _this.client.updatePlayerID(playerID);
        _this.playerID = playerID;
        _this.forceUpdate();
      };

      _this.updateCredentials = function (credentials) {
        _this.client.updateCredentials(credentials);
        _this.credentials = credentials;
        _this.forceUpdate();
      };

      _this.overrideGameState = function (state) {
        _this.setState({ gameStateOverride: state });
      };

      _this.client = Client({
        game: game,
        ai: ai,
        numPlayers: numPlayers,
        multiplayer: multiplayer,
        gameID: props.gameID,
        playerID: props.playerID,
        credentials: props.credentials,
        enhancer: enhancer
      });

      _this.gameID = props.gameID;
      _this.playerID = props.playerID;
      _this.credentials = props.credentials;

      _this.client.subscribe(function () {
        return _this.forceUpdate();
      });
      return _this;
    }

    createClass(WrappedBoard, [{
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        if (this.props.gameID != prevProps.gameID) {
          this.updateGameID(this.props.gameID);
        }
        if (this.props.playerID != prevProps.playerID) {
          this.updatePlayerID(this.props.playerID);
        }
        if (this.props.credentials != prevProps.credentials) {
          this.updateCredentials(this.props.credentials);
        }
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.client.connect();
      }
    }, {
      key: 'render',
      value: function render() {
        var _board = null;
        var _debug = null;

        var state = this.client.getState();
        var _props = this.props,
            debugProp = _props.debug,
            rest = objectWithoutProperties(_props, ['debug']);


        if (this.state.gameStateOverride) {
          state = _extends({}, state, this.state.gameStateOverride);
        }

        if (board) {
          _board = React.createElement(board, _extends({}, state, rest, {
            isMultiplayer: multiplayer !== undefined,
            moves: this.client.moves,
            events: this.client.events,
            gameID: this.gameID,
            playerID: this.playerID,
            reset: this.client.reset,
            undo: this.client.undo,
            redo: this.client.redo
          }));
        }

        if (debug !== false && debugProp) {
          var showGameInfo = (typeof debug === 'undefined' ? 'undefined' : _typeof(debug)) === 'object' && debug.showGameInfo;
          var dockControls = (typeof debug === 'undefined' ? 'undefined' : _typeof(debug)) === 'object' && debug.dockControls;
          _debug = React.createElement(Debug, {
            gamestate: state,
            reducer: this.client.reducer,
            store: this.client.store,
            isMultiplayer: multiplayer !== undefined,
            moves: this.client.moves,
            events: this.client.events,
            gameID: this.gameID,
            playerID: this.playerID,
            credentials: this.credentials,
            step: this.client.step,
            reset: this.client.reset,
            undo: this.client.undo,
            redo: this.client.redo,
            visualizeAI: ai && ai.visualize,
            overrideGameState: this.overrideGameState,
            updateGameID: this.updateGameID,
            updatePlayerID: this.updatePlayerID,
            updateCredentials: this.updateCredentials,
            showGameInfo: showGameInfo,
            dockControls: dockControls
          });
        }

        return React.createElement(
          'div',
          { className: 'client' },
          React.createElement(
            'span',
            null,
            _debug,
            _board
          )
        );
      }
    }]);
    return WrappedBoard;
  }(React.Component), _class.propTypes = {
    // The ID of a game to connect to.
    // Only relevant in multiplayer.
    gameID: PropTypes.string,
    // The ID of the player associated with this client.
    // Only relevant in multiplayer.
    playerID: PropTypes.string,
    // This client's authentication credentials.
    // Only relevant in multiplayer.
    credentials: PropTypes.string,
    // Enable / disable the Debug UI.
    debug: PropTypes.any
  }, _class.defaultProps = {
    gameID: 'default',
    playerID: null,
    credentials: null,
    debug: true
  }, _temp;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Client
 *
 * boardgame.io React Native client.
 *
 * @param {...object} game - The return value of `Game`.
 * @param {...object} numPlayers - The number of players.
 * @param {...object} board - The React component for the game.
 * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }
 *                                  to make a multiplayer client. The second
 *                                  syntax specifies a non-default socket server.
 * @param {...object} enhancer - Optional enhancer to send to the Redux store
 *
 * Returns:
 *   A React Native component that wraps board and provides an
 *   API through props for it to interact with the framework
 *   and dispatch actions such as MAKE_MOVE.
 */
function Client$2(_ref) {
  var _class, _temp;

  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      board = _ref.board,
      multiplayer = _ref.multiplayer,
      enhancer = _ref.enhancer;

  /*
   * WrappedBoard
   *
   * The main React component that wraps the passed in
   * board component and adds the API to its props.
   */
  return _temp = _class = function (_React$Component) {
    inherits(WrappedBoard, _React$Component);

    function WrappedBoard(props) {
      classCallCheck(this, WrappedBoard);

      var _this = possibleConstructorReturn(this, (WrappedBoard.__proto__ || Object.getPrototypeOf(WrappedBoard)).call(this, props));

      _this.client = Client({
        game: game,
        numPlayers: numPlayers,
        multiplayer: multiplayer,
        gameID: props.gameID,
        playerID: props.playerID,
        credentials: props.credentials,
        socketOpts: {
          transports: ['websocket']
        },
        enhancer: enhancer
      });

      _this.client.subscribe(function () {
        return _this.forceUpdate();
      });
      return _this;
    }

    createClass(WrappedBoard, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (nextProps.gameID != this.props.gameID) {
          this.client.updateGameID(nextProps.gameID);
        }
        if (nextProps.playerID != this.props.playerID) {
          this.client.updatePlayerID(nextProps.playerID);
        }
        if (nextProps.credentials != this.props.credentials) {
          this.client.updateCredentials(nextProps.credentials);
        }
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        this.client.connect();
      }
    }, {
      key: 'render',
      value: function render() {
        var _board = null;

        var state = this.client.getState();
        var _props = this.props,
            gameID = _props.gameID,
            playerID = _props.playerID,
            rest = objectWithoutProperties(_props, ['gameID', 'playerID']);


        if (board) {
          _board = React.createElement(board, _extends({}, state, rest, {
            gameID: gameID,
            playerID: playerID,
            isMultiplayer: multiplayer !== undefined,
            moves: this.client.moves,
            events: this.client.events,
            reset: this.client.reset,
            undo: this.client.undo,
            redo: this.client.redo
          }));
        }

        return _board;
      }
    }]);
    return WrappedBoard;
  }(React.Component), _class.propTypes = {
    // The ID of a game to connect to.
    // Only relevant in multiplayer.
    gameID: PropTypes.string,
    // The ID of the player associated with this client.
    // Only relevant in multiplayer.
    playerID: PropTypes.string,
    // This client's authentication credentials.
    // Only relevant in multiplayer.
    credentials: PropTypes.string
  }, _class.defaultProps = {
    gameID: 'default',
    playerID: null,
    credentials: null
  }, _temp;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Standard move that simulates passing.
 *
 * Creates two objects in G:
 * passOrder - An array of playerIDs capturing passes in the pass order.
 * allPassed - Set to true when all players have passed.
 */
var Pass = function Pass(G, ctx) {
  var passOrder = [];
  if (G.passOrder !== undefined) {
    passOrder = G.passOrder;
  }
  var playerID = ctx.playerID;
  passOrder.push(playerID);
  G = _extends({}, G, { passOrder: passOrder });
  if (passOrder.length >= ctx.numPlayers) {
    G.allPassed = true;
  }
  return G;
};

/**
 * Event to change the actionPlayers array.
 * @param {object} state - The game state.
 * @param {object} arg - An array of playerID's or <object> of:
 *   {
 *     value: [],   // array of playerID's (optional if all is set).
 *     all: true,   // set value to all playerID's
 *     once: true,  // players have one move.
 *   }
 */
function SetActionPlayers(state, arg) {
  var _actionPlayersOnce = false;
  var actionPlayers = [];

  if (arg.once) {
    _actionPlayersOnce = true;
  }

  if (arg.value) {
    actionPlayers = arg.value;
  }

  if (arg.all) {
    actionPlayers = [].concat(toConsumableArray(state.ctx.playOrder));
  }

  if (Array.isArray(arg)) {
    actionPlayers = arg;
  }

  return _extends({}, state, {
    ctx: _extends({}, state.ctx, { actionPlayers: actionPlayers, _actionPlayersOnce: _actionPlayersOnce })
  });
}

/**
 * Converts a playOrderPos index into its value in playOrder.
 * @param {Array} playOrder - An array of player ID's.
 * @param {number} playOrderPos - An index into the above.
 */
function getCurrentPlayer(playOrder, playOrderPos) {
  return playOrder[playOrderPos] + '';
}

/**
 * Called at the start of a phase to initialize turn order state.
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turnOrder - A turn order object for this phase.
 */
function InitTurnOrderState(G, ctx, turnOrder) {
  var playOrderPos = void 0;
  var actionPlayers = void 0;

  var t = turnOrder.first(G, ctx);

  if (t.playOrderPos !== undefined) {
    playOrderPos = t.playOrderPos;
  } else {
    playOrderPos = t;
  }

  var currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);

  if (t.actionPlayers !== undefined) {
    actionPlayers = t.actionPlayers;
  } else {
    actionPlayers = [currentPlayer];
  }

  return _extends({}, ctx, { currentPlayer: currentPlayer, playOrderPos: playOrderPos, actionPlayers: actionPlayers });
}

/**
 * Called at the end of each turn to update the turn order state.
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turnOrder - A turn order object for this phase.
 * @param {string} nextPlayer - An optional argument to endTurn that
                                may specify the next player.
 */
function UpdateTurnOrderState(G, ctx, turnOrder, nextPlayer) {
  var playOrderPos = ctx.playOrderPos;
  var currentPlayer = ctx.currentPlayer;
  var actionPlayers = ctx.actionPlayers;
  var endPhase = false;

  if (ctx.playOrder.includes(nextPlayer)) {
    playOrderPos = ctx.playOrder.indexOf(nextPlayer);
    currentPlayer = nextPlayer;
    actionPlayers = [currentPlayer];
  } else {
    var t = turnOrder.next(G, ctx);

    if (t == undefined) {
      endPhase = true;
    } else {
      if (t.playOrderPos !== undefined) {
        playOrderPos = t.playOrderPos;
      } else {
        playOrderPos = t;
      }

      currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);

      if (t.actionPlayers !== undefined) {
        actionPlayers = t.actionPlayers;
      } else {
        actionPlayers = [currentPlayer];
      }
    }
  }

  ctx = _extends({}, ctx, {
    playOrderPos: playOrderPos,
    currentPlayer: currentPlayer,
    actionPlayers: actionPlayers
  });

  return { endPhase: endPhase, ctx: ctx };
}

/**
 * Set of different turn orders possible in a phase.
 * These are meant to be passed to the `turnOrder` setting
 * in the flow objects.
 *
 * Each object defines the first player when the phase / game
 * begins, and also a function `next` to determine who the
 * next player is when the turn ends.
 *
 * first / next can also return an object of type
 * { playOrderPos, actionPlayers }
 * in which case they can also set actionPlayers simultaneously.
 *
 * The phase ends if next() returns undefined.
 */
var TurnOrder = {
  /**
   * DEFAULT
   *
   * The default round-robin turn order.
   */
  DEFAULT: {
    first: function first(G, ctx) {
      return ctx.playOrderPos;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * ONCE
   *
   * Another round-robin turn order, but goes around just once.
   * The phase ends after all players have played.
   */
  ONCE: {
    first: function first() {
      return 0;
    },
    next: function next(G, ctx) {
      if (ctx.playOrderPos < ctx.playOrder.length - 1) {
        return ctx.playOrderPos + 1;
      }
    }
  },

  /**
   * ANY
   *
   * currentPlayer switches around in round-robin fashion, but any player can play on each turn.
   */
  ANY: {
    first: function first(G, ctx) {
      return {
        actionPlayers: [].concat(toConsumableArray(ctx.playOrder)),
        playOrderPos: ctx.playOrderPos
      };
    },
    next: function next(G, ctx) {
      var playOrderPos = (ctx.playOrderPos + 1) % ctx.playOrder.length;
      return { actionPlayers: [].concat(toConsumableArray(ctx.playOrder)), playOrderPos: playOrderPos };
    }
  },

  /**
   * SKIP
   *
   * Round-robin, but skips over any players that have passed.
   * Meant to be used with Pass above.
   */

  SKIP: {
    first: function first(G, ctx) {
      return ctx.playOrderPos;
    },
    next: function next(G, ctx) {
      if (G.allPassed) return;
      var playOrderPos = ctx.playOrderPos;
      for (var i = 0; i < ctx.playOrder.length; i++) {
        playOrderPos = (playOrderPos + 1) % ctx.playOrder.length;
        if (!G.passOrder.includes(ctx.playOrder[playOrderPos] + '')) {
          return playOrderPos;
        }
      }
    }
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Helper to create a reducer that manages ctx (with the
 * ability to also update G).
 *
 * You probably want to use FlowWithPhases below, but you might
 * need to use this directly if you are creating a very customized
 * game flow that it cannot handle.
 *
 * @param {...object} ctx - Function with the signature
 *                          numPlayers => ctx
 *                          that determines the initial value of ctx.
 * @param {...object} events - Object containing functions
 *                             named after events that this
 *                             reducer will handle. Each function
 *                             has the following signature:
 *                             ({G, ctx}) => {G, ctx}
 * @param {...object} processMove - A function that's called whenever a move is made.
 *                                  (state, action, dispatch) => state.
 * @param {...object} optimisticUpdate - (G, ctx, move) => boolean
 *                                       Control whether a move should
 *                                       be executed optimistically on
 *                                       the client while waiting for
 *                                       the result of execution from
 *                                       the server.
 * @param {...object} canMakeMove - (G, ctx, moveName) => boolean
 *                                  Predicate to determine whether a
 *                                  particular move is allowed at
 *                                  this time.
 *
 * @param {...object} canUndoMove - (G, ctx, moveName) => boolean
 *                                  Predicate to determine whether a
 *                                  particular move is undoable at this
 *                                  time.
 */
function Flow(_ref) {
  var ctx = _ref.ctx,
      events = _ref.events,
      init = _ref.init,
      _processMove = _ref.processMove,
      optimisticUpdate = _ref.optimisticUpdate,
      _canMakeMove = _ref.canMakeMove,
      canUndoMove = _ref.canUndoMove;

  if (!ctx) ctx = function ctx() {
    return {};
  };
  if (!events) events = {};
  if (!init) init = function init(state) {
    return state;
  };
  if (!_processMove) _processMove = function processMove(state) {
    return state;
  };
  if (!_canMakeMove) _canMakeMove = function canMakeMove() {
    return true;
  };
  if (!canUndoMove) canUndoMove = function canUndoMove() {
    return true;
  };

  if (optimisticUpdate === undefined) {
    optimisticUpdate = function optimisticUpdate() {
      return true;
    };
  }

  var dispatch = function dispatch(state, action) {
    var payload = action.payload;

    if (events.hasOwnProperty(payload.type)) {
      var context = { playerID: payload.playerID, dispatch: dispatch };
      var args = [state].concat(payload.args);
      var oldLog = state.log || [];
      var log = [].concat(toConsumableArray(oldLog), [action]);
      var newState = events[payload.type].apply(context, args);
      return _extends({}, newState, { log: log });
    }
    return state;
  };

  return {
    ctx: ctx,
    init: init,
    canUndoMove: canUndoMove,

    eventNames: Object.getOwnPropertyNames(events),

    processMove: function processMove(state, action) {
      return _processMove(state, action, dispatch);
    },

    processGameEvent: function processGameEvent(state, action) {
      return dispatch(state, action, dispatch);
    },

    optimisticUpdate: optimisticUpdate,

    canPlayerCallEvent: function canPlayerCallEvent(G, ctx, playerID) {
      return ctx.currentPlayer == playerID;
    },

    canPlayerMakeMove: function canPlayerMakeMove(G, ctx, playerID) {
      var actionPlayers = ctx.actionPlayers || [];
      return actionPlayers.includes(playerID);
    },

    canMakeMove: function canMakeMove(G, ctx, moveName) {
      // Disallow moves once the game is over.
      if (ctx.gameover !== undefined) return false;
      // User-provided move validation.
      return _canMakeMove(G, ctx, moveName);
    }
  };
}

/**
 * FlowWithPhases
 *
 * A very customizable game flow that introduces phases to the
 * game. Each phase can be configured with:
 * - A custom turn order.
 * - Automatically executed setup / cleanup code.
 * - Custom phase end conditions.
 * - A move whitelist that disallows other moves during the phase.
 *
 * @param {...object} movesPerTurn - End the turn automatically after a certain number
 *                                   of moves (default: undefined, i.e. the turn does
 *                                   not automatically end after a certain number of moves).
 *
 * @param {...object} endTurnIf - The turn automatically ends if this
 *                                returns a truthy value
 *                                (checked after each move).
 *                                If the return value is a playerID,
 *                                that player is the next player
 *                                (instead of following the turn order).
 *                                (G, ctx) => boolean|string
 *
 * @param {...object} endGameIf - The game automatically ends if this function
 *                                returns anything (checked after each move).
 *                                The return value is available at ctx.gameover.
 *                                (G, ctx) => {}
 *
 * @param {...object} onTurnBegin - Any code to run when a turn begins.
 *                                 (G, ctx) => G
 *
 * @param {...object} onTurnEnd - Any code to run when a turn ends.
 *                                (G, ctx) => G
 *
 * @param {...object} onMove - Any code to run at the end of a move.
 *                             (G, ctx, { type: 'moveName', args: [] }) => G
 *
 * @param {...object} turnOrder - Customize the turn order (see turn-order.js).
 *
 * @param {...object} endTurn - Set to false to disable the `endTurn` event.
 *
 * @param {...object} endPhase - Set to false to disable the `endPhase` event.
 *
 * @param {...object} endGame - Set to true to enable the `endGame` event.
 *
 * @param {...object} setActionPlayers - Set to true to enable the `setActionPlayers` event.
 *
 * @param {...object} allowedMoves - List of moves that are allowed.
 *                                   This can be either a list of
 *                                   move names or a function with the
 *                                   signature (G, ctx) => [].
 *                                   (default: null, i.e. all moves are allowed).
 *
 * @param {...object} undoableMoves - List of moves that are undoable,
 *                                   (default: null, i.e. all moves are undoable).
 *
 *
 * @param {...object} optimisticUpdate - (G, ctx, move) => boolean
 *                                       Control whether a move should
 *                                       be executed optimistically on
 *                                       the client while waiting for
 *                                       the result of execution from
 *                                       the server.
 *
 * @param {...object} phases - A list of phases in the game.
 *
 * Each phase is described by an object:
 *
 * All the properties below override their global equivalents
 * above whenever they are defined (i.e. the global setting
 * is used if a phase-specific setting is absent).
 *
 * {
 *   name: 'phase_name',
 *
 *   // Any setup code to run before the phase begins.
 *   onPhaseBegin: (G, ctx) => G,
 *
 *   // Any cleanup code to run after the phase ends.
 *   onPhaseEnd: (G, ctx) => G,
 *
 *   // The phase ends if this function returns a truthy value.
 *   // If the return value is the name of another phase,
 *   // that will be chosen as the next phase (as opposed
 *   // to the next one in round-robin order).
 *   endPhaseIf: (G, ctx) => boolean|string,
 *
 *   Phase-specific options that override their global equivalents:
 *
 *   // A phase-specific endTurnIf.
 *   endTurnIf: (G, ctx) => boolean,
 *
 *   // A phase-specific endGameIf.
 *   endGameIf: (G, ctx) => {},
 *
 *   // A phase-specific onTurnBegin
 *   onTurnBegin: (G, ctx) => G,
 *
 *   // A phase-specific onTurnEnd.
 *   onTurnEnd: (G, ctx) => G,
 *
 *   // A phase-specific onMove.
 *   onMove - (G, ctx) => G,
 *
 *   // A phase-specific turnOrder.
 *   turnOrder: TurnOrder.DEFAULT,
 *
 *   // A phase-specific movesPerTurn.
 *   movesPerTurn: integer,
 *
 *   // List of moves or a function that returns a list of moves
 *   // that are allowed in this phase.
 *   allowedMoves: (G, ctx) => ['moveA', ...],
 *
 *   // List of moves that are undoable.
 *   undoableMoves: ['moveA', ...],
 * }
 */
function FlowWithPhases(_ref2) {
  var phases = _ref2.phases,
      movesPerTurn = _ref2.movesPerTurn,
      endTurnIf = _ref2.endTurnIf,
      endGameIf = _ref2.endGameIf,
      onTurnBegin = _ref2.onTurnBegin,
      onTurnEnd = _ref2.onTurnEnd,
      onMove = _ref2.onMove,
      turnOrder = _ref2.turnOrder,
      endTurn = _ref2.endTurn,
      endPhase = _ref2.endPhase,
      endGame = _ref2.endGame,
      setActionPlayers = _ref2.setActionPlayers,
      undoableMoves = _ref2.undoableMoves,
      allowedMoves = _ref2.allowedMoves,
      _optimisticUpdate = _ref2.optimisticUpdate;

  // Attach defaults.
  if (endPhase === undefined && phases) {
    endPhase = true;
  }
  if (endTurn === undefined) {
    endTurn = true;
  }
  if (endGame === undefined) {
    endGame = false;
  }
  if (setActionPlayers === undefined) {
    setActionPlayers = false;
  }
  if (_optimisticUpdate === undefined) {
    _optimisticUpdate = function optimisticUpdate() {
      return true;
    };
  }
  if (!phases) phases = [{ name: 'default' }];
  if (!endTurnIf) endTurnIf = function endTurnIf() {
    return false;
  };
  if (!endGameIf) endGameIf = function endGameIf() {
    return undefined;
  };
  if (!onTurnBegin) onTurnBegin = function onTurnBegin(G) {
    return G;
  };
  if (!onTurnEnd) onTurnEnd = function onTurnEnd(G) {
    return G;
  };
  if (!onMove) onMove = function onMove(G) {
    return G;
  };
  if (!turnOrder) turnOrder = TurnOrder.DEFAULT;
  if (allowedMoves === undefined) allowedMoves = null;
  if (undoableMoves === undefined) undoableMoves = null;

  var phaseKeys = [];
  var phaseMap = {};

  for (var i = 0; i < phases.length; i++) {
    var conf = phases[i];
    phaseKeys.push(conf.name);
    phaseMap[conf.name] = conf;

    if (conf.endPhaseIf === undefined) {
      conf.endPhaseIf = function () {
        return false;
      };
    }
    if (conf.onPhaseBegin === undefined) {
      conf.onPhaseBegin = function (G) {
        return G;
      };
    }
    if (conf.onPhaseEnd === undefined) {
      conf.onPhaseEnd = function (G) {
        return G;
      };
    }
    if (conf.movesPerTurn === undefined) {
      conf.movesPerTurn = movesPerTurn;
    }
    if (conf.endTurnIf === undefined) {
      conf.endTurnIf = endTurnIf;
    }
    if (conf.endGameIf === undefined) {
      conf.endGameIf = endGameIf;
    }
    if (conf.onTurnBegin === undefined) {
      conf.onTurnBegin = onTurnBegin;
    }
    if (conf.onTurnEnd === undefined) {
      conf.onTurnEnd = onTurnEnd;
    }
    if (conf.onMove === undefined) {
      conf.onMove = onMove;
    }
    if (conf.turnOrder === undefined) {
      conf.turnOrder = turnOrder;
    }
    if (conf.undoableMoves === undefined) {
      conf.undoableMoves = undoableMoves;
    }
    if (conf.allowedMoves === undefined) {
      conf.allowedMoves = allowedMoves;
    }
    if (typeof conf.allowedMoves !== 'function') {
      (function () {
        var t = conf.allowedMoves;
        conf.allowedMoves = function () {
          return t;
        };
      })();
    }
  }

  var shouldEndPhase = function shouldEndPhase(_ref3) {
    var G = _ref3.G,
        ctx = _ref3.ctx;

    var conf = phaseMap[ctx.phase];
    return conf.endPhaseIf(G, ctx);
  };

  var shouldEndTurn = function shouldEndTurn(_ref4) {
    var G = _ref4.G,
        ctx = _ref4.ctx;

    var conf = phaseMap[ctx.phase];

    var currentPlayerMoves = ctx.stats.turn.numMoves[ctx.currentPlayer] || 0;
    if (conf.movesPerTurn && currentPlayerMoves >= conf.movesPerTurn) {
      return true;
    }
    return conf.endTurnIf(G, ctx);
  };

  // Helper to perform start-of-phase initialization.
  var startPhase = function startPhase(state, config) {
    var G = config.onPhaseBegin(state.G, state.ctx);
    var ctx = InitTurnOrderState(state.G, state.ctx, config.turnOrder);

    // Reset stats.
    ctx.stats = _extends({}, ctx.stats, {
      phase: _extends({}, ctx.stats.phase, {
        numMoves: {},
        allPlayed: false
      })
    });

    var allowedMoves = config.allowedMoves(G, ctx);
    return _extends({}, state, { G: G, ctx: _extends({}, ctx, { allowedMoves: allowedMoves }) });
  };

  var startTurn = function startTurn(state, config) {
    var G = config.onTurnBegin(state.G, state.ctx);

    var plainCtx = state.ctx;
    plainCtx = Random.detach(plainCtx);
    plainCtx = Events.detach(plainCtx);
    var _undo = [{ G: G, ctx: plainCtx }];

    var ctx = _extends({}, state.ctx);
    ctx.allowedMoves = config.allowedMoves(G, ctx);

    // Reset stats.
    ctx.stats = _extends({}, ctx.stats, {
      turn: _extends({}, ctx.stats.turn, {
        numMoves: {},
        allPlayed: false
      })
    });

    return _extends({}, state, { G: G, ctx: ctx, _undo: _undo, _redo: [] });
  };

  var startGame = function startGame(state, config) {
    state = startPhase(state, config);
    state = startTurn(state, config);
    return state;
  };

  /**
   * endPhase (game event)
   *
   * Ends the current phase.
   * Also runs any phase cleanup code and setup code for the
   * next phase (if any).
   *
   * The next phase is chosen in a round-robin fashion, with the
   * option to override that by passing nextPhase.
   */
  function endPhaseEvent(state, nextPhase, cascadeDepth) {
    var G = state.G;
    var ctx = state.ctx;

    // Run any cleanup code for the phase that is about to end.
    var conf = phaseMap[ctx.phase];
    G = conf.onPhaseEnd(G, ctx);

    var gameover = conf.endGameIf(G, ctx);
    if (gameover !== undefined) {
      return _extends({}, state, { G: G, ctx: _extends({}, ctx, { gameover: gameover }) });
    }

    // Update the phase.
    if (nextPhase in phaseMap) {
      ctx = _extends({}, ctx, { phase: nextPhase });
    } else {
      var index = phaseKeys.indexOf(ctx.phase);
      index = (index + 1) % phases.length;
      var phase = phases[index].name;
      ctx = _extends({}, ctx, { phase: phase });
    }

    // Run any setup code for the new phase.
    state = startPhase(_extends({}, state, { G: G, ctx: ctx }), phaseMap[ctx.phase]);

    var origTurn = state.ctx.turn;

    // End the new phase automatically if necessary.
    // In order to avoid infinite loops, this is called
    // a finite number of times.
    if (!cascadeDepth) cascadeDepth = 0;
    if (cascadeDepth < phases.length - 1) {
      var end = shouldEndPhase(state);
      if (end) {
        state = this.dispatch(state, automaticGameEvent('endPhase', [end, cascadeDepth + 1], this.playerID));
      }
    }

    // End turn if endTurnIf returns something
    // (and the turn has not already been ended by a nested endPhase call).
    var endTurn = shouldEndTurn(state);
    if (endTurn && state.ctx.turn == origTurn) {
      state = this.dispatch(state, automaticGameEvent('endTurn', [endTurn], this.playerID));
    }

    return state;
  }

  /**
   * endTurn (game event)
   *
   * Ends the current turn.
   * Passes the turn to the next turn in a round-robin fashion.
   */
  function endTurnEvent(state, nextPlayer) {
    var G = state.G,
        ctx = state.ctx;


    var conf = phaseMap[ctx.phase];

    // Prevent ending the turn if movesPerTurn haven't been made.
    var currentPlayerMoves = ctx.stats.turn.numMoves[ctx.currentPlayer] || 0;
    if (conf.movesPerTurn && currentPlayerMoves < conf.movesPerTurn) {
      return state;
    }

    // Run turn-end triggers.
    G = conf.onTurnEnd(G, ctx);

    // Update gameover.
    var gameover = conf.endGameIf(G, ctx);
    if (gameover !== undefined) {
      return _extends({}, state, { G: G, ctx: _extends({}, ctx, { gameover: gameover }) });
    }

    var endPhase = false;

    // Update turn order state.
    {
      var _UpdateTurnOrderState = UpdateTurnOrderState(G, ctx, conf.turnOrder, nextPlayer),
          a = _UpdateTurnOrderState.endPhase,
          b = _UpdateTurnOrderState.ctx;

      endPhase = a;
      ctx = b;
    }

    // Update turn.
    var turn = ctx.turn + 1;

    // Update state.
    ctx = _extends({}, ctx, { turn: turn });

    // End phase if condition is met.
    var endPhaseArg = shouldEndPhase(state);
    if (endPhaseArg) {
      endPhase = true;
    }

    if (endPhase) {
      return this.dispatch(_extends({}, state, { G: G, ctx: ctx }), automaticGameEvent('endPhase', [endPhaseArg], this.playerID));
    }

    return startTurn(_extends({}, state, { G: G, ctx: ctx }), conf);
  }

  function endGameEvent(state, arg) {
    if (arg === undefined) {
      arg = true;
    }

    return _extends({}, state, { ctx: _extends({}, state.ctx, { gameover: arg }) });
  }

  function updateStats(state, key, playerID) {
    var moves = (state.ctx.stats[key].numMoves[playerID] || 0) + 1;
    var numMoves = _extends({}, state.ctx.stats[key].numMoves, defineProperty({}, playerID, moves));
    var t = _extends({}, state.ctx.stats[key], { numMoves: numMoves });

    if (Object.keys(numMoves).length == state.ctx.numPlayers) {
      t.allPlayed = true;
    }

    var stats = _extends({}, state.ctx.stats, defineProperty({}, key, t));
    var ctx = _extends({}, state.ctx, { stats: stats });

    return _extends({}, state, { ctx: ctx });
  }

  function processMove(state, action, dispatch) {
    var conf = phaseMap[state.ctx.phase];

    state = updateStats(state, 'turn', action.playerID);
    state = updateStats(state, 'phase', action.playerID);

    // Update actionPlayers if _actionPlayersOnce is set.
    var actionPlayers = state.ctx.actionPlayers;
    if (state.ctx._actionPlayersOnce == true) {
      var playerID = action.playerID;
      actionPlayers = actionPlayers.filter(function (id) {
        return id !== playerID;
      });
    }

    state = _extends({}, state, {
      ctx: _extends({}, state.ctx, {
        actionPlayers: actionPlayers
      })
    });

    var G = conf.onMove(state.G, state.ctx, action);
    state = _extends({}, state, { G: G });

    var origTurn = state.ctx.turn;
    var gameover = conf.endGameIf(state.G, state.ctx);

    // End the phase automatically if endPhaseIf is true or if endGameIf returns.
    var endPhase = shouldEndPhase(state);
    if (endPhase || gameover !== undefined) {
      state = dispatch(state, automaticGameEvent('endPhase', [endPhase], action.playerID));
      // Update to the new phase configuration
      conf = phaseMap[state.ctx.phase];
    }

    // End the turn automatically if endTurnIf is true or if endGameIf returns.
    // (but not if endPhase above already ends the turn).
    var endTurn = shouldEndTurn(state);
    if (state.ctx.turn == origTurn && (endTurn || gameover !== undefined)) {
      state = dispatch(state, automaticGameEvent('endTurn', [endTurn], action.playerID));
    }

    // End the game automatically if endGameIf returns.
    if (gameover !== undefined) {
      return _extends({}, state, { ctx: _extends({}, state.ctx, { gameover: gameover }) });
    }

    // Update allowedMoves.
    var allowedMoves = conf.allowedMoves(state.G, state.ctx);
    state = _extends({}, state, { ctx: _extends({}, state.ctx, { allowedMoves: allowedMoves }) });

    // Update undo / redo state.
    if (!endTurn) {
      var undo$$1 = state._undo || [];
      var moveType = action.type;

      var plainCtx = state.ctx;
      plainCtx = Random.detach(plainCtx);
      plainCtx = Events.detach(plainCtx);

      state = _extends({}, state, {
        _undo: [].concat(toConsumableArray(undo$$1), [{ G: state.G, ctx: plainCtx, moveType: moveType }]),
        _redo: []
      });
    }

    return state;
  }

  var canMakeMove = function canMakeMove(G, ctx, moveName) {
    var conf = phaseMap[ctx.phase];
    var moves = conf.allowedMoves(G, ctx);
    if (!moves) return true;
    return moves.includes(moveName);
  };

  var canUndoMove = function canUndoMove(G, ctx, moveName) {
    var conf = phaseMap[ctx.phase];
    if (!conf.undoableMoves) return true;
    return conf.undoableMoves.includes(moveName);
  };

  var enabledEvents = {};
  if (endTurn) {
    enabledEvents['endTurn'] = endTurnEvent;
  }
  if (endPhase) {
    enabledEvents['endPhase'] = endPhaseEvent;
  }
  if (endGame) {
    enabledEvents['endGame'] = endGameEvent;
  }
  if (setActionPlayers) {
    enabledEvents['setActionPlayers'] = SetActionPlayers;
  }

  return Flow({
    ctx: function ctx(numPlayers) {
      return {
        numPlayers: numPlayers,
        turn: 0,
        currentPlayer: '0',
        currentPlayerMoves: 0,
        playOrder: Array.from(Array(numPlayers), function (d, i) {
          return i + '';
        }),
        playOrderPos: 0,
        stats: { turn: { numMoves: {} }, phase: { numMoves: {} } },
        allPlayed: false,
        phase: phases[0].name
      };
    },
    init: function init(state) {
      return startGame(state, phases[0]);
    },
    optimisticUpdate: function optimisticUpdate(G, ctx, action) {
      // Some random code was executed.
      if (ctx._random !== undefined && ctx._random.prngstate !== undefined) {
        return false;
      }
      return _optimisticUpdate(G, ctx, action);
    },
    events: enabledEvents,
    processMove: processMove,
    canMakeMove: canMakeMove,
    canUndoMove: canUndoMove
  });
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Game
 *
 * Helper to generate the game move reducer. The returned
 * reducer has the following signature:
 *
 * (G, action, ctx) => {}
 *
 * You can roll your own if you like, or use any Redux
 * addon to generate such a reducer.
 *
 * The convention used in this framework is to
 * have action.type contain the name of the move, and
 * action.args contain any additional arguments as an
 * Array.
 *
 * Game({
 *   name: 'tic-tac-toe',
 *
 *   setup: (numPlayers) => {
 *     const G = {...};
 *     return G;
 *   },
 *
 *   moves: {
 *     'moveWithoutArgs': (G, ctx) => {
 *       return Object.assign({}, G, ...);
 *     },
 *     'moveWithArgs': (G, ctx, arg0, arg1) => {
 *       return Object.assign({}, G, ...);
 *     }
 *   },
 *
 *   playerView: (G, ctx, playerID) => { ... },
 *
 *   flow: {
 *     endGameIf: (G, ctx) => { ... },
 *     endTurnIf: (G, ctx) => { ... },
 *
 *     phases: [
 *       { name: 'A', setup: (G, ctx) => G, cleanup: (G, ctx) => G },
 *       { name: 'B', setup: (G, ctx) => G, cleanup: (G, ctx) => G },
 *       ...
 *     ]
 *   },
 * })
 *
 * @param {...object} setup - Function that returns the initial state of G.
 *
 * @param {...object} moves - A dictionary of move functions.
 *
 * @param {...object} playerView - A function that returns a
 *                                 derivative of G tailored for
 *                                 the specified player.
 *
 * @param {...object} flow - Customize the flow of the game (see flow.js).
 *                           Must contain the return value of Flow().
 *                           If it contains any other object, it is presumed to be a
 *                           configuration object for FlowWithPhases().
 *
 * @param {...object} seed - Seed for the PRNG.
 */
function Game(_ref) {
  var name = _ref.name,
      setup = _ref.setup,
      moves = _ref.moves,
      playerView = _ref.playerView,
      flow = _ref.flow,
      seed = _ref.seed;

  if (name === undefined) name = 'default';
  if (setup === undefined) setup = function setup() {
    return {};
  };
  if (moves === undefined) moves = {};
  if (playerView === undefined) playerView = function playerView(G) {
    return G;
  };

  if (!flow || flow.processGameEvent === undefined) {
    flow = FlowWithPhases(flow || {});
  }

  return {
    name: name,
    setup: setup,
    playerView: playerView,
    flow: flow,
    seed: seed,
    moveNames: Object.getOwnPropertyNames(moves),
    processMove: function processMove(G, action, ctx) {
      if (moves.hasOwnProperty(action.type)) {
        var context = { playerID: action.playerID };
        var ctxWithPlayerID = _extends({}, ctx, { playerID: action.playerID });
        var args = [G, ctxWithPlayerID].concat(action.args);
        return moves[action.type].apply(context, args);
      }
      return G;
    }
  };
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Grid
 *
 * Component that will show children on a cartesian regular grid.
 *
 * Props:
 *   rows       - Number of rows (height) of the grid.
 *   cols       - Number of columns (width) of the grid.
 *   style      - CSS style of the Grid HTML element.
 *   colorMap   - A map from 'x,y' => color.
 *   onClick    - (x, y) => {}
 *                Called when a square is clicked.
 *   onMouseOver    - (x, y) => {}
 *                Called when a square is mouse over.
 *   onMouseOut    - (x, y) => {}
 *                Called when a square is mouse out.
 *
 * Usage:
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}/>
 * </Grid>
 */
var Grid = function (_React$Component) {
  inherits(Grid, _React$Component);

  function Grid() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Grid);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Grid.__proto__ || Object.getPrototypeOf(Grid)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Grid, [{
    key: '_getCellColor',
    value: function _getCellColor(x, y) {
      var key = x + ',' + y;
      var color = 'white';
      if (key in this.props.colorMap) {
        color = this.props.colorMap[key];
      }
      return color;
    }
  }, {
    key: '_getGrid',
    value: function _getGrid() {
      if (!this.props.outline) {
        return null;
      }

      var squares = [];
      for (var x = 0; x < this.props.cols; x++) {
        for (var y = 0; y < this.props.rows; y++) {
          squares.push(React.createElement(Square, {
            key: this.props.cols * y + x,
            style: { fill: this._getCellColor(x, y) },
            x: x,
            y: y,
            size: this.props.cellSize,
            onClick: this.onClick,
            onMouseOver: this.onMouseOver,
            onMouseOut: this.onMouseOut
          }));
        }
      }
      return squares;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var tokens = React.Children.map(this.props.children, function (child) {
        return React.cloneElement(child, {
          template: Square,
          onClick: _this2.onClick,
          onMouseOver: _this2.onMouseOver,
          onMouseOut: _this2.onMouseOut
        });
      });

      return React.createElement(
        'svg',
        {
          viewBox: '0 0 ' + this.props.cols + ' ' + this.props.rows,
          style: this.props.style
        },
        React.createElement(
          'g',
          null,
          this._getGrid()
        ),
        tokens
      );
    }
  }]);
  return Grid;
}(React.Component);

/**
 * Square
 *
 * Component that renders a square inside a Grid.
 *
 * Props:
 *   x       - X coordinate on grid coordinates.
 *   y       - Y coordinate on grid coordinates.
 *   size    - Square size.
 *   style   - Custom styling.
 *   onClick - Invoked when a Square is clicked.
 *   onMouseOver - Invoked when a Square is mouse over.
 *   onMouseOut - Invoked when a Square is mouse out.
 *
 * Not meant to be used by the end user directly (use Token).
 * Also not exposed in the NPM.
 */
Grid.propTypes = {
  rows: PropTypes.number.isRequired,
  cols: PropTypes.number.isRequired,
  outline: PropTypes.bool,
  style: PropTypes.object,
  colorMap: PropTypes.object,
  cellSize: PropTypes.number,
  onClick: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func,
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.element), PropTypes.element])
};
Grid.defaultProps = {
  colorMap: {},
  outline: true,
  cellSize: 1
};

var _initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this.onClick = function (args) {
    if (_this4.props.onClick) {
      _this4.props.onClick(args);
    }
  };

  this.onMouseOver = function (args) {
    if (_this4.props.onMouseOver) {
      _this4.props.onMouseOver(args);
    }
  };

  this.onMouseOut = function (args) {
    if (_this4.props.onMouseOut) {
      _this4.props.onMouseOut(args);
    }
  };
};

var Square = function (_React$Component2) {
  inherits(Square, _React$Component2);

  function Square() {
    var _ref2;

    var _temp2, _this3, _ret2;

    classCallCheck(this, Square);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _ret2 = (_temp2 = (_this3 = possibleConstructorReturn(this, (_ref2 = Square.__proto__ || Object.getPrototypeOf(Square)).call.apply(_ref2, [this].concat(args))), _this3), _this3.onClick = function () {
      _this3.props.onClick({
        x: _this3.props.x,
        y: _this3.props.y
      });
    }, _this3.onMouseOver = function () {
      _this3.props.onMouseOver({
        x: _this3.props.x,
        y: _this3.props.y
      });
    }, _this3.onMouseOut = function () {
      _this3.props.onMouseOut({
        x: _this3.props.x,
        y: _this3.props.y
      });
    }, _temp2), possibleConstructorReturn(_this3, _ret2);
  }

  createClass(Square, [{
    key: 'render',
    value: function render() {
      var tx = this.props.x * this.props.size;
      var ty = this.props.y * this.props.size;

      // If a child is passed, render child.
      if (this.props.children) {
        return React.createElement(
          'g',
          {
            onClick: this.onClick,
            onMouseOver: this.onMouseOver,
            onMouseOut: this.onMouseOut,
            transform: 'translate(' + tx + ', ' + ty + ')'
          },
          this.props.children
        );
      }

      // If no child, render a square.
      return React.createElement(
        'g',
        {
          onClick: this.onClick,
          onMouseOver: this.onMouseOver,
          onMouseOut: this.onMouseOut,
          transform: 'translate(' + tx + ', ' + ty + ')'
        },
        React.createElement('rect', {
          style: this.props.style,
          width: this.props.size,
          height: this.props.size,
          x: 0,
          y: 0
        })
      );
    }
  }]);
  return Square;
}(React.Component);
Square.propTypes = {
  x: PropTypes.number.isRequired,
  y: PropTypes.number.isRequired,
  size: PropTypes.number,
  style: PropTypes.any,
  onClick: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func,
  children: PropTypes.element
};
Square.defaultProps = {
  size: 1,
  x: 0,
  y: 0,
  style: { fill: '#fff' }
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-syle
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Token
 *
 * Component that represents a board game piece (or token).
 * Can be used by itself or with one of the grid systems
 * provided (Grid or HexGrid).
 *
 * A token renders as a square inside a Grid and a
 * hexagon inside a HexGrid. Additionally, you can pass
 * it a child if you want any other custom rendering.
 *
 * Props:
 *   x       - X coordinate on grid / hex grid.
 *   y       - Y coordinate on grid / hex grid.
 *   z       - Z coordinate on hex grid.
 *   animate - Changes in position are animated if true.
 *   animationDuration - Length of animation.
 *   onClick - Called when the token is clicked.
 *   onMouseOver - Called when the token is mouse over.
 *   onMouseOut - Called when the token is mouse out.
 *
 * Usage:
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}/>
 * </Grid>
 *
 * <HexGrid>
 *   <Token x={1} y={2} z={-3}/>
 * </HexGrid>
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}>
 *     <Knight color="white"/>
 *   </Token>
 * </Grid>
 */

var Token = function (_React$Component) {
  inherits(Token, _React$Component);

  function Token() {
    classCallCheck(this, Token);
    return possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).apply(this, arguments));
  }

  createClass(Token, [{
    key: 'componentWillMount',


    /**
     * Sets the x and y of the state on creation.
     */
    value: function componentWillMount() {
      this.setState(this.getCoords());
    }

    /**
     * If there is a change in props, saves old x/y,
     * and current time. Starts animation.
     * @param {Object} nextProps Next props.
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var oldCoord = this.getCoords();
      var newCoord = this.getCoords(nextProps);

      // Debounce.
      if (oldCoord.x == newCoord.x && oldCoord.y == newCoord.y) {
        return;
      }

      this.setState(_extends({}, this.state, {
        originTime: Date.now(),
        originX: oldCoord.x,
        originY: oldCoord.y,
        originZ: oldCoord.z
      }));

      requestAnimationFrame(this._animate(Date.now()));
    }

    /**
     * Recursively animates x and y.
     * @param {number} now Unix timestamp when this was called.
     */

  }, {
    key: '_animate',
    value: function _animate(now) {
      var _this2 = this;

      return function () {
        var elapsed = now - _this2.state.originTime;
        var svgCoord = _this2.getCoords();
        if (elapsed < _this2.props.animationDuration && _this2.props.animate) {
          var percentage = _this2._easeInOutCubic(elapsed, 0, 1, _this2.props.animationDuration);

          _this2.setState(_extends({}, _this2.state, {
            x: (svgCoord.x - _this2.state.originX) * percentage + _this2.state.originX,
            y: (svgCoord.y - _this2.state.originY) * percentage + _this2.state.originY,
            z: (svgCoord.z - _this2.state.originZ) * percentage + _this2.state.originZ
          }));

          requestAnimationFrame(_this2._animate(Date.now()));
        } else {
          _this2.setState(_extends({}, _this2.state, {
            x: svgCoord.x,
            y: svgCoord.y,
            z: svgCoord.z
          }));
        }
      }.bind(this);
    }

    /**
     * Gets SVG x/y/z coordinates.
     * @param {Object} props Props object to get coordinates from.
     * @return {Object} Object with x, y and z parameters.
     */

  }, {
    key: 'getCoords',
    value: function getCoords() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

      return { x: props.x, y: props.y, z: props.z };
    }

    /**
     * Returns animation easing value. See http://easings.net/#easeInOutCubic.
     * @param {number} t Current time.
     * @param {number} b Beginning value.
     * @param {number} c Final value.
     * @param {number} d Duration.
     */

  }, {
    key: '_easeInOutCubic',
    value: function _easeInOutCubic(t, b, c, d) {
      t /= d / 2;
      if (t < 1) return c / 2 * t * t * t + b;
      t -= 2;
      return c / 2 * (t * t * t + 2) + b;
    }
  }, {
    key: 'render',
    value: function render() {
      var Component = this.props.template;

      return React.createElement(
        Component,
        {
          x: this.state.x,
          y: this.state.y,
          z: this.state.z,
          style: this.props.style,
          onClick: this.props.onClick,
          onMouseOver: this.props.onMouseOver,
          onMouseOut: this.props.onMouseOut
        },
        this.props.children
      );
    }
  }]);
  return Token;
}(React.Component);

Token.propTypes = {
  x: PropTypes.number,
  y: PropTypes.number,
  z: PropTypes.number,
  template: PropTypes.any,
  style: PropTypes.any,
  animate: PropTypes.bool,
  onClick: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func,
  children: PropTypes.element,
  animationDuration: PropTypes.number
};
Token.defaultProps = {
  animationDuration: 750,
  template: Square
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var Logo = function Logo(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return React.createElement(
    'svg',
    {
      width: width || 128,
      height: height || 128,
      xmlns: 'http://www.w3.org/2000/svg',
      viewBox: '0 0 128 128'
    },
    React.createElement('path', {
      d: 'M64,120.37,15.27,92.28V35.91L64,7.82l48.73,28.09V92.28Z',
      fill: '#373748'
    }),
    React.createElement('path', {
      fill: '#000',
      d: 'M64,124,12,94V34L64,4l52,30V94ZM18.33,90.37,64,116.74l45.67-26.37V37.63L64,11.26,18.33,37.63Z'
    }),
    React.createElement('path', {
      d: 'M81.77,43.17c5.92,0,10.51,1.72,13.57,5.16,3.25,3.44,4.77,8.41,4.77,14.71q0,10.32-5.15,16.06c-3.44,3.82-8.22,5.73-14.53,5.73-5.92,0-10.51-1.72-13.56-5.35-3.25-3.63-4.78-8.6-4.78-15.29s1.72-12,5.16-15.67S75.46,43.17,81.77,43.17Zm-.57,5.16c-4.4,0-7.45,1.15-9.56,3.63s-3,6.31-3,11.66c0,5.73,1,9.74,3,12.42,2.11,2.48,5.16,3.82,9.56,3.82s7.64-1.34,9.74-3.82,3.25-6.5,3.25-11.85c0-5.54-1.15-9.55-3.25-12C88.65,49.48,85.59,48.33,81.2,48.33Z',
      fill: '#fff'
    }),
    React.createElement('path', {
      d: 'M39.35,71.45l.19,12.8H33.43L33.62,72l-.19-28.48h6.11l-.19,27.9Z',
      fill: '#fff'
    })
  );
};

Logo.propTypes = {
  width: PropTypes.string,
  height: PropTypes.string
};

__$styleInject("/*\n * Copyright 2017 The boardgame.io Authors\n *\n * Use of this source code is governed by a MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\n\n.bgio-card {\n  display: flex;\n  user-select: none;\n  font-family: monospace;\n  font-weight: bold;\n  font-size: 18px;\n  color: #ababab;\n  text-align: center;\n  flex-direction: column;\n  justify-content: center;\n  cursor: pointer;\n  background: #fff;\n  border-radius: 6px;\n  border: 1px solid #cdcdcd;\n  width: 100px;\n  height: 140px;\n  transition: all 0.1s;\n  overflow: hidden;\n}\n\n.bgio-card:not(.no-hover):hover {\n  transform: scale(1.2);\n}\n\n.bgio-card__front,\n.bgio-card__back {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  overflow: hidden;\n}\n\n.bgio-card__back {\n  background-image: url(\"data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 64 64' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M8 16c4.418 0 8-3.582 8-8s-3.582-8-8-8-8 3.582-8 8 3.582 8 8 8zm0-2c3.314 0 6-2.686 6-6s-2.686-6-6-6-6 2.686-6 6 2.686 6 6 6zm33.414-6l5.95-5.95L45.95.636 40 6.586 34.05.636 32.636 2.05 38.586 8l-5.95 5.95 1.414 1.414L40 9.414l5.95 5.95 1.414-1.414L41.414 8zM40 48c4.418 0 8-3.582 8-8s-3.582-8-8-8-8 3.582-8 8 3.582 8 8 8zm0-2c3.314 0 6-2.686 6-6s-2.686-6-6-6-6 2.686-6 6 2.686 6 6 6zM9.414 40l5.95-5.95-1.414-1.414L8 38.586l-5.95-5.95L.636 34.05 6.586 40l-5.95 5.95 1.414 1.414L8 41.414l5.95 5.95 1.414-1.414L9.414 40z' fill='%23ababab' fill-opacity='0.4' fill-rule='evenodd'/%3E%3C/svg%3E\");\n  background-position: 2px 2px;\n  outline: 8px solid #eee;\n  outline-offset: -20px;\n}\n", undefined);

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var Card = function Card(_ref) {
  var back = _ref.back,
      canHover = _ref.canHover,
      className = _ref.className,
      front = _ref.front,
      isFaceUp = _ref.isFaceUp,
      rest = objectWithoutProperties(_ref, ['back', 'canHover', 'className', 'front', 'isFaceUp']);

  var classNames = ['bgio-card'];
  if (!canHover) classNames.push('no-hover');
  if (className) classNames.push(className);

  return React.createElement(
    'div',
    _extends({ className: classNames.join(' ') }, rest),
    isFaceUp ? front : back
  );
};

Card.propTypes = {
  back: PropTypes.node,
  canHover: PropTypes.bool,
  className: PropTypes.string,
  front: PropTypes.node,
  isFaceUp: PropTypes.bool
};

Card.defaultProps = {
  back: React.createElement(
    'div',
    { className: 'bgio-card__back' },
    React.createElement(Logo, { width: '48' })
  ),
  canHover: true,
  front: React.createElement(
    'div',
    { className: 'bgio-card__front' },
    'Card'
  ),
  isFaceUp: false
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * HexGrid
 *
 * Component to display a hex grid.
 * Reference: https://www.redblobgames.com/grids/hexagons/.
 *
 * We use cube co-ordinates (see reference).
 *
 * Props:
 *   levels     - The number of levels around the central hex.
 *   style      - CSS style of the HTML element.
 *
 * Usage:
 *
 * <HexGrid levels={5}>
 *   <Token x={0} y={0} z={0}/>
 * </HexGrid>
 */
var HexGrid = function (_React$Component) {
  inherits(HexGrid, _React$Component);

  function HexGrid() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, HexGrid);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = HexGrid.__proto__ || Object.getPrototypeOf(HexGrid)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$1.call(_this), _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(HexGrid, [{
    key: '_getCellColor',
    value: function _getCellColor(x, y, z) {
      var key = x + ',' + y + ',' + z;
      var color = 'white';
      if (key in this.props.colorMap) {
        color = this.props.colorMap[key];
      }
      return color;
    }
  }, {
    key: '_getGrid',
    value: function _getGrid() {
      if (!this.props.outline) {
        return null;
      }

      var hexes = [];
      var r = this.props.levels;
      for (var x = -r; x <= r; x++) {
        for (var y = -r; y <= r; y++) {
          var z = -x - y;
          if (Math.abs(z) > r) continue;
          hexes.push(React.createElement(Hex, {
            key: x + ':' + y + ':' + z,
            style: { fill: this._getCellColor(x, y, z) },
            x: x,
            y: y,
            z: z,
            size: this.props.cellSize,
            onClick: this.onClick,
            onMouseOver: this.onMouseOver,
            onMouseOut: this.onMouseOut
          }));
        }
      }
      return hexes;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var tokens = React.Children.map(this.props.children, function (child) {
        return React.cloneElement(child, {
          template: Hex,
          onClick: _this2.onClick,
          onMouseOver: _this2.onMouseOver,
          onMouseOut: _this2.onMouseOut
        });
      });

      var t = this.props.cellSize * this.props.levels * 2;
      return React.createElement(
        'svg',
        {
          viewBox: -t + ' ' + -t + ' ' + 2 * t + ' ' + 2 * t,
          style: this.props.style
        },
        React.createElement(
          'g',
          null,
          this._getGrid()
        ),
        tokens
      );
    }
  }]);
  return HexGrid;
}(React.Component);

/**
 * Hex (flat-topped).
 *
 * Component that renders a hexagon inside a HexGrid.
 *
 * Props:
 *   x       - X coordinate (cube coordinates).
 *   y       - Y coordinate (cube coordinates).
 *   z       - Z coordinate (cube coordinates).
 *   size    - Hex size.
 *   style   - Custom styling.
 *   onClick - Invoked when a Hex is clicked.
 *   onMouseOver - Invoked when a Hex is mouse over.
 *   onMouseOut - Invoked when a Hex is mouse out.
 *
 * Not meant to be used by the end user directly (use Token).
 * Also not exposed in the NPM.
 */
HexGrid.propTypes = {
  levels: PropTypes.number.isRequired,
  outline: PropTypes.bool,
  style: PropTypes.object,
  colorMap: PropTypes.object,
  cellSize: PropTypes.number,
  onClick: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func,
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.element), PropTypes.element])
};
HexGrid.defaultProps = {
  levels: 5,
  colorMap: {},
  outline: true,
  cellSize: 1
};

var _initialiseProps$1 = function _initialiseProps() {
  var _this4 = this;

  this.onClick = function (args) {
    if (_this4.props.onClick) {
      _this4.props.onClick(args);
    }
  };

  this.onMouseOver = function (args) {
    if (_this4.props.onMouseOver) {
      _this4.props.onMouseOver(args);
    }
  };

  this.onMouseOut = function (args) {
    if (_this4.props.onMouseOut) {
      _this4.props.onMouseOut(args);
    }
  };
};

var Hex = function (_React$Component2) {
  inherits(Hex, _React$Component2);

  function Hex(props) {
    classCallCheck(this, Hex);

    var _this3 = possibleConstructorReturn(this, (Hex.__proto__ || Object.getPrototypeOf(Hex)).call(this, props));

    _this3.onClick = function () {
      _this3.props.onClick({
        x: _this3.props.x,
        y: _this3.props.y,
        z: _this3.props.z
      });
    };

    _this3.onMouseOver = function () {
      _this3.props.onMouseOver({
        x: _this3.props.x,
        y: _this3.props.y,
        z: _this3.props.z
      });
    };

    _this3.onMouseOut = function () {
      _this3.props.onMouseOut({
        x: _this3.props.x,
        y: _this3.props.y,
        z: _this3.props.z
      });
    };

    return _this3;
  }

  createClass(Hex, [{
    key: 'render',
    value: function render() {
      var tx = this.center.x;
      var ty = this.center.y;

      // If a child is passed, render child.
      if (this.props.children) {
        return React.createElement(
          'g',
          {
            onClick: this.onClick,
            onMouseOver: this.onMouseOver,
            onMouseOut: this.onMouseOut,
            transform: 'translate(' + tx + ', ' + ty + ')'
          },
          this.props.children
        );
      }

      // If no child, render a hex.
      return React.createElement(
        'g',
        {
          onClick: this.onClick,
          onMouseOver: this.onMouseOver,
          onMouseOut: this.onMouseOut,
          transform: 'translate(' + tx + ', ' + ty + ')'
        },
        React.createElement('polygon', {
          style: this.props.style,
          points: this.points,
          stroke: '#aaa',
          strokeWidth: 0.01
        })
      );
    }
  }, {
    key: 'width',
    get: function get$$1() {
      return this.props.size * 2;
    }
  }, {
    key: 'height',
    get: function get$$1() {
      return (Math.sqrt(3) / 2 * this.width).toFixed(3);
    }

    /**
     * Get the co-ordinates of the hex center.
     */

  }, {
    key: 'center',
    get: function get$$1() {
      var q = this.props.x;
      var r = this.props.z;
      var x = this.props.size * 3 * q / 2.0;
      var y = this.props.size * Math.sqrt(3) * (r + q / 2.0);
      return { x: x, y: y };
    }

    /**
     * Get the points of the vertices.
     */

  }, {
    key: 'points',
    get: function get$$1() {
      //   b____c
      //   /    \
      // a/      \d
      //  \      /
      //   \____/
      //   f    e

      var s = this.props.size;
      var h = this.height;

      var xa = -s;
      var xb = -s / 2.0;
      var xc = +s / 2.0;
      var xd = +s;
      var xe = xc;
      var xf = xb;

      var ya = 0.0;
      var yb = h / 2.0;
      var yc = yb;
      var yd = ya;
      var ye = -h / 2.0;
      var yf = ye;

      var flatTop = [xa + ',' + ya, xb + ',' + yb, xc + ',' + yc, xd + ',' + yd, xe + ',' + ye, xf + ',' + yf];

      return flatTop.join(' ');
    }
  }]);
  return Hex;
}(React.Component);
Hex.propTypes = {
  x: PropTypes.number,
  y: PropTypes.number,
  z: PropTypes.number,
  size: PropTypes.number,
  style: PropTypes.any,
  onClick: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func,
  children: PropTypes.element
};
Hex.defaultProps = {
  size: 1,
  x: 0,
  y: 0,
  z: 0,
  style: { fill: '#fff' }
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Simulates the game till the end or a max depth.
 *
 * @param {...object} game - The game object.
 * @param {...object} bots - An array of bots.
 * @param {...object} state - The game state to start from.
 */


var Bot = function () {
  function Bot(_ref2) {
    var _this = this;

    var enumerate = _ref2.enumerate,
        seed = _ref2.seed;
    classCallCheck(this, Bot);

    this.enumerate = function (G, ctx, playerID) {
      var actions = _this.enumerateFn(G, ctx, playerID);
      return actions.map(function (a) {
        if (a.payload !== undefined) {
          return a;
        }

        if (a.move !== undefined) {
          return makeMove(a.move, a.args, playerID);
        }

        if (a.event !== undefined) {
          return gameEvent(a.event, a.args, playerID);
        }
      });
    };

    this.enumerateFn = enumerate;
    this.seed = seed;
  }

  createClass(Bot, [{
    key: 'random',
    value: function random(arg) {
      var number = void 0;

      if (this.seed !== undefined) {
        var r = null;
        if (this.prngstate) {
          r = new alea('', { state: this.prngstate });
        } else {
          r = new alea(this.seed, { state: true });
        }

        number = r();
        this.prngstate = r.state();
      } else {
        number = Math.random();
      }

      if (arg) {
        if (arg.length) {
          var id = Math.floor(number * arg.length);
          return arg[id];
        } else {
          return Math.floor(number * arg);
        }
      }

      return number;
    }
  }]);
  return Bot;
}();

var RandomBot = function (_Bot) {
  inherits(RandomBot, _Bot);

  function RandomBot() {
    classCallCheck(this, RandomBot);
    return possibleConstructorReturn(this, (RandomBot.__proto__ || Object.getPrototypeOf(RandomBot)).apply(this, arguments));
  }

  createClass(RandomBot, [{
    key: 'play',
    value: function play(_ref3, playerID) {
      var G = _ref3.G,
          ctx = _ref3.ctx;

      var moves = this.enumerate(G, ctx, playerID);
      return { action: this.random(moves) };
    }
  }]);
  return RandomBot;
}(Bot);

var MCTSBot = function (_Bot2) {
  inherits(MCTSBot, _Bot2);

  function MCTSBot(_ref4) {
    var enumerate = _ref4.enumerate,
        seed = _ref4.seed,
        objectives = _ref4.objectives,
        game = _ref4.game,
        iterations = _ref4.iterations,
        playoutDepth = _ref4.playoutDepth;
    classCallCheck(this, MCTSBot);

    var _this3 = possibleConstructorReturn(this, (MCTSBot.__proto__ || Object.getPrototypeOf(MCTSBot)).call(this, { enumerate: enumerate, seed: seed }));

    if (objectives === undefined) {
      objectives = function objectives() {
        return {};
      };
    }

    _this3.objectives = objectives;
    _this3.reducer = CreateGameReducer({ game: game });
    _this3.iterations = iterations || 1000;
    _this3.playoutDepth = playoutDepth || 50;
    return _this3;
  }

  createClass(MCTSBot, [{
    key: 'createNode',
    value: function createNode(_ref5) {
      var state = _ref5.state,
          parentAction = _ref5.parentAction,
          parent = _ref5.parent,
          playerID = _ref5.playerID;
      var G = state.G,
          ctx = state.ctx;


      var actions = [];
      var objectives = [];

      if (playerID !== undefined) {
        actions = this.enumerate(G, ctx, playerID);
        objectives = this.objectives(G, ctx, playerID);
      } else {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = ctx.actionPlayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _playerID = _step.value;

            actions = actions.concat(this.enumerate(G, ctx, _playerID));
            objectives = objectives.concat(this.objectives(G, ctx, _playerID));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return {
        // Game state at this node.
        state: state,
        // Parent of the node.
        parent: parent,
        // Move used to get to this node.
        parentAction: parentAction,
        // Unexplored actions.
        actions: actions,
        // Current objectives.
        objectives: objectives,
        // Children of the node.
        children: [],
        // Number of simulations that pass through this node.
        visits: 0,
        // Number of wins for this node.
        value: 0
      };
    }
  }, {
    key: 'select',
    value: function select(node) {
      // This node has unvisited children.
      if (node.actions.length > 0) {
        return node;
      }

      // This is a terminal node.
      if (node.children.length == 0) {
        return node;
      }

      var selectedChild = null;
      var best = 0.0;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;

          var childVisits = child.visits + Number.EPSILON;
          var uct = child.value / childVisits + Math.sqrt(2 * Math.log(node.visits) / childVisits);
          if (selectedChild == null || uct > best) {
            best = uct;
            selectedChild = child;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return this.select(selectedChild);
    }
  }, {
    key: 'expand',
    value: function expand(node) {
      var actions = node.actions;

      if (actions.length == 0 || node.state.ctx.gameover !== undefined) {
        return node;
      }

      var id = this.random(actions.length);
      var action = actions[id];
      node.actions.splice(id, 1);
      var childState = this.reducer(node.state, action);
      var childNode = this.createNode({
        state: childState,
        parentAction: action,
        parent: node
      });
      node.children.push(childNode);
      return childNode;
    }
  }, {
    key: 'playout',
    value: function playout(node) {
      var _this4 = this;

      var state = node.state;

      var _loop = function _loop(i) {
        var _state = state,
            G = _state.G,
            ctx = _state.ctx;

        var moves = _this4.enumerate(G, ctx, ctx.actionPlayers[0]);

        // Check if any objectives are met.
        var objectives = _this4.objectives(G, ctx);
        var score = Object.keys(objectives).reduce(function (score, key) {
          var objective = objectives[key];
          if (objective.checker(G, ctx)) {
            return score + objective.weight;
          }
          return score;
        }, 0.0);

        // If so, stop and return the score.
        if (score > 0) {
          return {
            v: { score: score }
          };
        }

        if (!moves || moves.length == 0) {
          return {
            v: undefined
          };
        }

        var id = _this4.random(moves.length);
        var childState = _this4.reducer(state, moves[id]);
        state = childState;
      };

      for (var i = 0; i < this.playoutDepth && state.ctx.gameover === undefined; i++) {
        var _ret = _loop(i);

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }

      return state.ctx.gameover;
    }
  }, {
    key: 'backpropagate',
    value: function backpropagate(node) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      node.visits++;

      if (result.score !== undefined) {
        node.value += result.score;
      }

      if (result.draw === true) {
        node.value += 0.5;
      }

      if (node.parentAction && result.winner === node.parentAction.payload.playerID) {
        node.value++;
      }

      if (node.parent) {
        this.backpropagate(node.parent, result);
      }
    }
  }, {
    key: 'play',
    value: function play(state, playerID) {
      var root = this.createNode({ state: state, playerID: playerID });

      for (var i = 0; i < this.iterations; i++) {
        var leaf = this.select(root);
        var child = this.expand(leaf);
        var result = this.playout(child);
        this.backpropagate(child, result);
      }

      var selectedChild = null;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = root.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _child = _step3.value;

          if (selectedChild == null || _child.visits > selectedChild.visits) {
            selectedChild = _child;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var action = selectedChild && selectedChild.parentAction;
      var metadata = root;

      return { action: action, metadata: metadata };
    }
  }]);
  return MCTSBot;
}(Bot);

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

function AI(_ref) {
  var bot = _ref.bot,
      enumerate = _ref.enumerate,
      visualize = _ref.visualize;

  if (!bot) {
    bot = MCTSBot;
  }

  return { bot: bot, enumerate: enumerate, visualize: visualize };
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var main = {
  Client: Client,
  ReactClient: Client$1,
  ReactNativeClient: Client$2,
  Game: Game,
  Flow: Flow,
  FlowWithPhases: FlowWithPhases,
  TurnOrder: TurnOrder,
  Pass: Pass,
  Card: Card,
  Token: Token,
  Grid: Grid,
  HexGrid: HexGrid,
  AI: AI,
  RandomBot: RandomBot,
  MCTSBot: MCTSBot
};

return main;

})));
