(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('mousetrap'), require('flatted'), require('redux'), require('socket.io-client')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'mousetrap', 'flatted', 'redux', 'socket.io-client'], factory) :
	(factory((global.Client = {}),global.React,global.PropTypes,global.Mousetrap,global.Flatted,global.Redux,global.io));
}(this, (function (exports,React,PropTypes,Mousetrap,flatted,redux,io) { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

React = React && React.hasOwnProperty('default') ? React['default'] : React;
PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
Mousetrap = Mousetrap && Mousetrap.hasOwnProperty('default') ? Mousetrap['default'] : Mousetrap;
io = io && io.hasOwnProperty('default') ? io['default'] : io;

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

function AssignShortcuts(moveNames, eventNames, blacklist) {
  var shortcuts = {};

  var events = {};
  for (var name in moveNames) {
    events[name] = name;
  }
  for (var _name in eventNames) {
    events[_name] = _name;
  }

  var taken = {};
  for (var i = 0; i < blacklist.length; i++) {
    var c = blacklist[i];
    taken[c] = true;
  }

  // Try assigning the first char of each move as the shortcut.
  var t = taken;
  var canUseFirstChar = true;
  for (var _name2 in events) {
    var shortcut = _name2[0];
    if (t[shortcut]) {
      canUseFirstChar = false;
      break;
    }

    t[shortcut] = true;
    shortcuts[_name2] = shortcut;
  }
  if (canUseFirstChar) {
    return shortcuts;
  }

  // If those aren't unique, use a-z.
  t = taken;
  var next = 97;
  shortcuts = {};
  for (var _name3 in events) {
    var _shortcut = String.fromCharCode(next);

    while (t[_shortcut]) {
      next++;
      _shortcut = String.fromCharCode(next);
    }

    t[_shortcut] = true;
    shortcuts[_name3] = _shortcut;
  }
  return shortcuts;
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var Item = function Item(props) {
  return React.createElement(
    'div',
    { className: 'gameinfo-item' },
    React.createElement(
      'strong',
      null,
      props.name,
      ' '
    ),
    React.createElement(
      'div',
      null,
      JSON.stringify(props.value)
    )
  );
};

Item.propTypes = {
  name: PropTypes.string.isRequired,
  value: PropTypes.any
};

var GameInfo = function GameInfo(props) {
  return React.createElement(
    'section',
    { className: 'gameinfo' },
    React.createElement(Item, { name: 'gameID', value: props.gameID }),
    React.createElement(Item, { name: 'playerID', value: props.playerID }),
    React.createElement(Item, { name: 'isActive', value: props.isActive }),
    props.isMultiplayer && React.createElement(
      'span',
      null,
      React.createElement(Item, { name: 'isConnected', value: props.isConnected }),
      React.createElement(Item, { name: 'isMultiplayer', value: props.isMultiplayer })
    )
  );
};

GameInfo.propTypes = {
  gameID: PropTypes.string,
  playerID: PropTypes.string,
  isActive: PropTypes.bool,
  isConnected: PropTypes.bool,
  isMultiplayer: PropTypes.bool
};

__$styleInject("/*\n * Copyright 2017 The boardgame.io Authors\n *\n * Use of this source code is governed by a MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\n\n.debug-ui {\n  text-align: left;\n  overflow-x: hidden;\n  overflow-y: scroll;\n  background: #fefefe;\n  border-left: 1px solid #ddd;\n  box-shadow: -1px 0 10px #aaa;\n  position: absolute;\n  width: 300px;\n  right: 0;\n  top: 0;\n  height: 100%;\n  font-family: monospace;\n  font-size: 14px;\n}\n\n#debug-controls.docktop {\n  position: fixed;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-evenly;\n  align-items: center;\n  padding-left: 10px;\n  padding-right: 10px;\n  min-width: 500px;\n  top: 0;\n  right: 300px;\n  height: 50px;\n  background: #fff;\n  box-shadow: -3px 3px 3px #ccc;\n}\n\n@media only screen and (max-device-width: 750px) {\n  .debug-ui {\n    display: none;\n  }\n}\n\n.debug-ui .gameinfo {\n  background: #ddd;\n  position: fixed;\n  bottom: 0;\n  box-sizing: border-box;\n  width: 285px;\n  margin-left: -20px;\n  margin-bottom: 0;\n  padding: 10px;\n}\n\n.debug-ui .gameinfo-item div {\n  float: right;\n  text-align: right;\n}\n\n.debug-ui .ai-visualization {\n  position: fixed;\n  opacity: 100%;\n  right: 300px;\n  height: 100%;\n  width: 100%;\n  max-width: 3000px;\n  background: #fafafa;\n  border-right: 1px solid #ddd;\n}\n\n.debug-ui .pane {\n  float: left;\n  padding: 20px;\n  box-sizing: border-box;\n  min-width: 300px;\n  max-width: 400px;\n  opacity: 0.8;\n}\n\n.debug-ui section {\n  margin-bottom: 20px;\n}\n\n.debug-ui textarea {\n  resize: none;\n}\n\n.debug-ui .move {\n  cursor: pointer;\n  margin-bottom: 10px;\n  color: #666;\n}\n\n.debug-ui .move:hover {\n  color: #333;\n}\n\n.debug-ui .move.active {\n  color: #111;\n  font-weight: bold;\n}\n\n.debug-ui .move-error {\n  color: #a00;\n  font-weight: bold;\n}\n\n.debug-ui .arg-field {\n  outline: none;\n  font-family: monospace;\n}\n\n.debug-ui .key {\n  margin-bottom: 5px;\n}\n\n.debug-ui .key-box {\n  display: inline-block;\n  cursor: pointer;\n  min-width: 10px;\n  padding-left: 5px;\n  padding-right: 5px;\n  height: 20px;\n  line-height: 20px;\n  text-align: center;\n  border: 1px solid #ccc;\n  box-shadow: 1px 1px 1px #888;\n  background: #eee;\n  color: #444;\n}\n\n.debug-ui .key-box:hover {\n  background: #ddd;\n}\n\n.debug-ui .key.active .key-box {\n  background: #ddd;\n  border: 1px solid #999;\n  box-shadow: none;\n}\n\n.debug-ui .key-child {\n  display: inline-block;\n  height: 20px;\n  margin-left: 10px;\n}\n\n.debug-ui .menu {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n}\n\n.debug-ui .menu .item {\n  cursor: pointer;\n  margin-top: -10px;\n  margin-bottom: 20px;\n  margin-right: 10px;\n  padding: 5px;\n  min-width: 50px;\n  text-align: center;\n}\n\n.debug-ui .menu .item.active {\n  font-weight: bold;\n  border-bottom: 3px solid #ccc;\n}\n\n.debug-ui .player-box {\n  display: flex;\n  flex-direction: row;\n}\n\n.debug-ui .player {\n  cursor: pointer;\n  text-align: center;\n  width: 30px;\n  height: 30px;\n  line-height: 30px;\n  background: #eee;\n  border: 3px solid #fff;\n  box-sizing: content-box;\n}\n\n.debug-ui .player.current {\n  background: #555;\n  color: #eee;\n  font-weight: bold;\n}\n\n.debug-ui .player.active {\n  border: 3px solid #ff7f50;\n}\n", undefined);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * KeyboardShortcut
 *
 * Registers a keyboard shortcut to activate the
 * associated child component that is passed in.
 *
 * When the key is pressed, 'active' is set to true
 * in the prop passed to the child.
 */
var KeyboardShortcut = function (_React$Component) {
  inherits(KeyboardShortcut, _React$Component);

  function KeyboardShortcut() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, KeyboardShortcut);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = KeyboardShortcut.__proto__ || Object.getPrototypeOf(KeyboardShortcut)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      active: false
    }, _this.deactivate = function () {
      _this.setState({ active: false });
    }, _this.activate = function () {
      _this.setState({ active: true });
      if (_this.props.onPress) {
        _this.props.onPress();
        _this.setState({ active: false });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(KeyboardShortcut, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      Mousetrap.bind(this.props.value, function (e) {
        e.preventDefault();
        _this2.activate();
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      Mousetrap.unbind(this.props.value);
    }
  }, {
    key: 'render',
    value: function render() {
      var child = this.props.children;
      if (_typeof(this.props.children) === _typeof(this)) {
        child = React.cloneElement(this.props.children, {
          active: this.state.active,
          deactivate: this.deactivate,
          activate: this.activate
        });
      }

      var className = 'key';
      if (this.state.active) {
        className += ' active';
      }

      return React.createElement(
        'div',
        { className: className },
        React.createElement(
          'div',
          { className: 'key-box', onClick: this.activate },
          this.props.value
        ),
        React.createElement(
          'div',
          { className: 'key-child' },
          child
        )
      );
    }
  }]);
  return KeyboardShortcut;
}(React.Component);
KeyboardShortcut.propTypes = {
  value: PropTypes.string.isRequired,
  children: PropTypes.any,
  onPress: PropTypes.func
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Controls that are triggered by keyboard shortcuts.
 */
var Controls = function Controls(props) {
  var ai = null;

  if (props.step) {
    ai = [React.createElement(
      KeyboardShortcut,
      { key: '4', value: '4', onPress: props.step },
      'step'
    ), React.createElement(
      KeyboardShortcut,
      { key: '5', value: '5', onPress: props.simulate },
      'simulate'
    )];
  }

  var style = null;
  var className = 'controls';
  if (props.dockTop) {
    className += ' docktop';
  }
  if (props.help) {
    className += ' help';
  }

  var display = props.help && !props.dockTop ? 'block' : 'none';

  return React.createElement(
    'section',
    { id: 'debug-controls', style: style, className: className },
    React.createElement(
      KeyboardShortcut,
      { value: '1', onPress: props.reset },
      'reset'
    ),
    React.createElement(
      KeyboardShortcut,
      { value: '2', onPress: props.save },
      'save'
    ),
    React.createElement(
      KeyboardShortcut,
      { value: '3', onPress: props.restore },
      'restore'
    ),
    ai,
    props.dockTop || React.createElement(
      KeyboardShortcut,
      { value: '?', onPress: props.toggleHelp },
      'show more'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        'd'
      ),
      ' show/hide this pane'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        'l'
      ),
      ' show/hide log'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        'i'
      ),
      ' show/hide game info tab'
    ),
    React.createElement(
      'div',
      { className: 'key', style: { display: display } },
      React.createElement(
        'div',
        { className: 'key-box' },
        't'
      ),
      ' dock controls'
    )
  );
};

Controls.propTypes = {
  help: PropTypes.bool,
  toggleHelp: PropTypes.func,
  step: PropTypes.func,
  simulate: PropTypes.func,
  reset: PropTypes.func,
  save: PropTypes.func,
  restore: PropTypes.func,
  dockTop: PropTypes.bool
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Component that renders information about the
 * players in the game (whose turn it is etc.).
 */
var PlayerInfo = function (_React$Component) {
  inherits(PlayerInfo, _React$Component);

  function PlayerInfo() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, PlayerInfo);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = PlayerInfo.__proto__ || Object.getPrototypeOf(PlayerInfo)).call.apply(_ref, [this].concat(args))), _this), _this.onClick = function (playerID) {
      var arg = playerID == _this.props.playerID ? null : playerID;
      _this.props.onClick(arg);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(PlayerInfo, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var players = [];

      var _loop = function _loop(i) {
        var playerID = i + '';

        var className = 'player';

        if (playerID === _this2.props.ctx.currentPlayer) {
          className += ' current';
        }

        if (playerID === _this2.props.playerID) {
          className += ' active';
        }

        players.push(React.createElement(
          'div',
          {
            className: className,
            key: i,
            onClick: function onClick() {
              return _this2.onClick(playerID);
            }
          },
          playerID
        ));
      };

      for (var i = 0; i < this.props.ctx.numPlayers; i++) {
        _loop(i);
      }

      return React.createElement(
        'div',
        { className: 'player-box' },
        players
      );
    }
  }]);
  return PlayerInfo;
}(React.Component);
PlayerInfo.propTypes = {
  ctx: PropTypes.any.isRequired,
  playerID: PropTypes.any,
  onClick: PropTypes.func
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * DebugMove
 *
 * Component that allows the user to dispatch a move from
 * the debug pane. The user is presented with the textarea
 * to enter any additional arguments.
 */
var DebugMove = function (_React$Component) {
  inherits(DebugMove, _React$Component);

  function DebugMove() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, DebugMove);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DebugMove.__proto__ || Object.getPrototypeOf(DebugMove)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      error: ''
    }, _this.onSubmit = function (value) {
      var error = '';

      try {
        var argArray = new Function('return [' + value + ']')();
        _this.props.fn.apply(_this, argArray);
      } catch (e) {
        error = '' + e;
      }

      _this.setState({
        error: error,
        focus: false,
        enterArg: false
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(DebugMove, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        null,
        React.createElement(
          KeyboardShortcut,
          { value: this.props.shortcut },
          React.createElement(DebugMoveArgField, { name: this.props.name, onSubmit: this.onSubmit })
        ),
        this.state.error ? React.createElement(
          'span',
          { className: 'move-error' },
          this.state.error
        ) : null
      );
    }
  }]);
  return DebugMove;
}(React.Component);

DebugMove.propTypes = {
  name: PropTypes.string.isRequired,
  shortcut: PropTypes.string.isRequired,
  fn: PropTypes.func.isRequired
};
var DebugMoveArgField = function (_React$Component2) {
  inherits(DebugMoveArgField, _React$Component2);

  function DebugMoveArgField() {
    var _ref2;

    var _temp2, _this2, _ret2;

    classCallCheck(this, DebugMoveArgField);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _ret2 = (_temp2 = (_this2 = possibleConstructorReturn(this, (_ref2 = DebugMoveArgField.__proto__ || Object.getPrototypeOf(DebugMoveArgField)).call.apply(_ref2, [this].concat(args))), _this2), _this2.onKeyDown = function (e) {
      if (e.key == 'Enter') {
        e.preventDefault();
        var value = _this2.span.innerText;
        _this2.props.onSubmit(value);
        _this2.span.innerText = '';
        _this2.props.deactivate();
      }

      if (e.key == 'Escape') {
        e.preventDefault();
        _this2.props.deactivate();
      }
    }, _temp2), possibleConstructorReturn(_this2, _ret2);
  }

  createClass(DebugMoveArgField, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.active) {
        this.span.focus();
      } else {
        this.span.blur();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var className = 'move';
      if (this.props.active) className += ' active';
      return React.createElement(
        'div',
        { className: className, onClick: this.props.activate },
        this.props.name,
        '(',
        React.createElement('span', {
          ref: function ref(r) {
            _this3.span = r;
          },
          className: 'arg-field',
          onBlur: this.props.deactivate,
          onKeyDown: this.onKeyDown,
          contentEditable: true
        }),
        ')'
      );
    }
  }]);
  return DebugMoveArgField;
}(React.Component);
DebugMoveArgField.propTypes = {
  name: PropTypes.string.isRequired,
  onSubmit: PropTypes.func.isRequired,
  active: PropTypes.bool,
  activate: PropTypes.func,
  deactivate: PropTypes.func
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var MAKE_MOVE = 'MAKE_MOVE';
var GAME_EVENT = 'GAME_EVENT';
var RESTORE = 'RESTORE';
var RESET = 'RESET';
var UNDO = 'UNDO';
var REDO = 'REDO';

__$styleInject("/*\n * Copyright 2017 The boardgame.io Authors\n *\n * Use of this source code is governed by a MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\n\n.gamelog {\n  display: grid;\n  grid-template-columns: 30px 1fr 30px;\n  :grid-auto-rows: auto;\n  grid-auto-flow: column;\n}\n\n.gamelog .turn-marker {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  grid-column: 1;\n  background: #555;\n  color: #eee;\n  text-align: center;\n  font-weight: bold;\n  border: 1px solid #888;\n}\n\n.gamelog .log-event {\n  grid-column: 2;\n  cursor: pointer;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  background: #fff;\n  border: 1px dotted #ccc;\n  border-left: 5px solid #ccc;\n  padding: 5px;\n  text-align: center;\n  color: #888;\n  font-size: 14px;\n  height: 25px;\n  line-height: 25px;\n}\n\n.gamelog .phase-marker {\n  grid-column: 3;\n  background: #555;\n  border: 1px solid #888;\n  color: #eee;\n  text-align: center;\n  font-weight: bold;\n  padding-top: 10px;\n  padding-bottom: 10px;\n  text-orientation: sideways;\n  writing-mode: vertical-rl;\n  line-height: 30px;\n}\n\n.gamelog.pinned .log-event {\n  opacity: 0.2;\n}\n\n.gamelog .log-event:hover {\n  border-style: solid;\n  background: #eee;\n}\n\n.gamelog .log-event.pinned {\n  border-style: solid;\n  background: #eee;\n  opacity: 1;\n}\n\n.gamelog div.player0 {\n  border-left-color: #ff851b;\n}\n\n.gamelog div.player1 {\n  border-left-color: #7fdbff;\n}\n\n.gamelog div.player2 {\n  border-left-color: #0074d9;\n}\n\n.gamelog div.player3 {\n  border-left-color: #39cccc;\n}\n\n.gamelog div.player4 {\n  border-left-color: #3d9970;\n}\n\n.gamelog div.player5 {\n  border-left-color: #2ecc40;\n}\n\n.gamelog div.player6 {\n  border-left-color: #01ff70;\n}\n\n.gamelog div.player7 {\n  border-left-color: #ffdc00;\n}\n\n.gamelog div.player8 {\n  border-left-color: #001f3f;\n}\n\n.gamelog div.player9 {\n  border-left-color: #ff4136;\n}\n\n.gamelog div.player10 {\n  border-left-color: #85144b;\n}\n\n.gamelog div.player11 {\n  border-left-color: #f012be;\n}\n\n.gamelog div.player12 {\n  border-left-color: #b10dc9;\n}\n\n.gamelog div.player13 {\n  border-left-color: #111111;\n}\n\n.gamelog div.player14 {\n  border-left-color: #aaaaaa;\n}\n\n.gamelog div.player15 {\n  border-left-color: #dddddd;\n}\n", undefined);

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * LogEvent
 *
 * Logs a single action in the game.
 */
var LogEvent = function LogEvent(props) {
  var action = props.action;
  var args = action.payload.args || [];
  var playerID = action.payload.playerID;
  var classNames = 'log-event player' + playerID;

  if (props.pinned) {
    classNames += ' pinned';
  }

  return React.createElement(
    'div',
    {
      className: classNames,
      onClick: function onClick() {
        return props.onLogClick(props.logIndex);
      },
      onMouseEnter: function onMouseEnter() {
        return props.onMouseEnter(props.logIndex);
      },
      onMouseLeave: function onMouseLeave() {
        return props.onMouseLeave();
      }
    },
    action.payload.type,
    '(',
    args.join(','),
    ')'
  );
};

LogEvent.propTypes = {
  action: PropTypes.any.isRequired,
  logIndex: PropTypes.number.isRequired,
  onLogClick: PropTypes.func.isRequired,
  onMouseEnter: PropTypes.func.isRequired,
  onMouseLeave: PropTypes.func.isRequired,
  pinned: PropTypes.bool
};

/**
 * TurnMarker
 *
 * The markers on the left of the log events that indicate
 * which turn the event belongs to.
 */
var TurnMarker = function TurnMarker(props) {
  return React.createElement(
    'div',
    { className: 'turn-marker', style: { gridRow: 'span ' + props.numEvents } },
    props.turn
  );
};

TurnMarker.propTypes = {
  turn: PropTypes.number.isRequired,
  numEvents: PropTypes.number.isRequired
};

/**
 * PhaseMarker
 *
 * The markers on the right of the log events that indicate
 * which phase the event belongs to.
 */
var PhaseMarker = function PhaseMarker(props) {
  return React.createElement(
    'div',
    {
      className: 'phase-marker',
      style: { gridRow: 'span ' + props.numEvents }
    },
    props.phase
  );
};

PhaseMarker.propTypes = {
  phase: PropTypes.string.isRequired,
  numEvents: PropTypes.number.isRequired
};

/**
 * GameLog
 *
 * Component to log the actions in the game.
 */
var GameLog = function (_React$Component) {
  inherits(GameLog, _React$Component);

  function GameLog() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, GameLog);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GameLog.__proto__ || Object.getPrototypeOf(GameLog)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      pinned: null
    }, _this.rewind = function (logIndex) {
      var state = _this.props.initialState;
      for (var i = 0; i <= logIndex; i++) {
        var action = _this.props.log[i];
        if (!action.automatic) {
          state = _this.props.reducer(state, action);
        }
      }
      return { G: state.G, ctx: state.ctx };
    }, _this.onLogClick = function (logIndex) {
      _this.setState(function (o) {
        var state = _this.rewind(logIndex);
        var metadata = _this.props.log[logIndex].payload.metadata;

        if (o.pinned === logIndex) {
          _this.props.onHover({ logIndex: logIndex, state: state, metadata: undefined });
          return { pinned: null };
        }

        _this.props.onHover({ logIndex: logIndex, state: state, metadata: metadata });
        return { pinned: logIndex };
      });
    }, _this.onMouseEnter = function (logIndex) {
      if (_this.state.pinned === null) {
        var state = _this.rewind(logIndex);
        _this.props.onHover({ logIndex: logIndex, state: state });
      }
    }, _this.onMouseLeave = function () {
      if (_this.state.pinned === null) {
        _this.props.onHover({ state: null });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(GameLog, [{
    key: 'render',
    value: function render() {
      var log = [];
      var turns = [];
      var phases = [];
      var eventsInCurrentPhase = 0;
      var eventsInCurrentTurn = 0;
      var state = this.props.initialState;

      var lastAction = 0;
      for (var i = 0; i < this.props.log.length; i++) {
        var action = this.props.log[i];
        if (action.type == MAKE_MOVE || !action.automatic) {
          lastAction = i;
        }
      }

      for (var _i = 0; _i < this.props.log.length; _i++) {
        var _action = this.props.log[_i];
        var oldTurn = state.ctx.turn;
        var oldPhase = state.ctx.phase;

        if (_action.type == MAKE_MOVE) {
          log.push(React.createElement(LogEvent, {
            key: _i,
            pinned: _i === this.state.pinned,
            logIndex: _i,
            onLogClick: this.onLogClick,
            onMouseEnter: this.onMouseEnter,
            onMouseLeave: this.onMouseLeave,
            action: _action
          }));

          eventsInCurrentTurn++;
          eventsInCurrentPhase++;
        }

        if (!_action.automatic) {
          state = this.props.reducer(state, _action);

          if (state.ctx.turn != oldTurn || state.ctx.gameover !== undefined || _i == lastAction) {
            turns.push(React.createElement(TurnMarker, {
              key: turns.length,
              turn: oldTurn,
              numEvents: eventsInCurrentTurn
            }));
            eventsInCurrentTurn = 0;
          }

          if (state.ctx.phase != oldPhase || state.ctx.gameover !== undefined || _i == lastAction) {
            phases.push(React.createElement(PhaseMarker, {
              key: phases.length,
              phase: oldPhase,
              numEvents: eventsInCurrentPhase
            }));
            eventsInCurrentPhase = 0;
          }
        }
      }

      var className = 'gamelog';
      if (this.state.pinned !== null) {
        className += ' pinned';
      }

      return React.createElement(
        'div',
        { className: className },
        turns,
        log,
        phases
      );
    }
  }]);
  return GameLog;
}(React.Component);
GameLog.propTypes = {
  onHover: PropTypes.func,
  reducer: PropTypes.func,
  initialState: PropTypes.any.isRequired,
  log: PropTypes.array.isRequired
};
GameLog.defaultProps = {
  onHover: function onHover() {}
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var makeMove = function makeMove(type, args, playerID, credentials) {
  return {
    type: MAKE_MOVE,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var gameEvent = function gameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials }
  };
};

/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials },
    automatic: true
  };
};

/**
 * Used to reset the Redux store's state.
 * @param {object} state - The state to restore.
 */
var restore = function restore(state) {
  return {
    type: RESTORE,
    state: state
  };
};

/**
 * Used to reset the game state.
 */
var reset = function reset() {
  return {
    type: RESET
  };
};

/**
 * Used to undo the last move.
 */
var undo = function undo() {
  return {
    type: UNDO
  };
};

/**
 * Used to redo the last undone move.
 */
var redo = function redo() {
  return {
    type: REDO
  };
};

var ActionCreators = Object.freeze({
	makeMove: makeMove,
	gameEvent: gameEvent,
	automaticGameEvent: automaticGameEvent,
	restore: restore,
	reset: reset,
	undo: undo,
	redo: redo
});

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Removes all the keys in ctx that begin with a _.
 */
function SanitizeCtx(ctx) {
  var r = {};
  for (var key in ctx) {
    if (!key.startsWith('_')) {
      r[key] = ctx[key];
    }
  }
  return r;
}

/**
 * Debug
 *
 * Debug pane that displays the game state objects,
 * allows you to dispatch moves,
 * and allows you to save / restore from localStorage.
 */
var Debug = function (_React$Component) {
  inherits(Debug, _React$Component);

  function Debug(props) {
    classCallCheck(this, Debug);

    var _this = possibleConstructorReturn(this, (Debug.__proto__ || Object.getPrototypeOf(Debug)).call(this, props));

    _this.saveState = function () {
      var json = flatted.stringify(_this.props.gamestate);
      window.localStorage.setItem('gamestate', json);
    };

    _this.restoreState = function () {
      var gamestateJSON = window.localStorage.getItem('gamestate');
      if (gamestateJSON !== null) {
        var gamestate = flatted.parse(gamestateJSON);
        _this.props.store.dispatch(restore(gamestate));
      }
    };

    _this.onClickMain = function () {
      _this.setState({ showLog: false });
    };

    _this.onClickLog = function () {
      _this.setState({ showLog: true });
    };

    _this.toggleHelp = function () {
      _this.setState(function (oldstate) {
        return { help: !oldstate.help };
      });
    };

    _this.onLogHover = function (_ref) {
      var state = _ref.state,
          metadata = _ref.metadata;

      _this.setState({ AIMetadata: metadata });
      _this.props.overrideGameState(state);
    };

    _this.simulate = function () {
      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10000;
      var sleepTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

      var step = function step() {
        var action = _this.props.step();
        if (action && iterations > 1) {
          iterations--;
          setTimeout(step, sleepTimeout);
        }
      };

      step();
    };

    _this.shortcuts = AssignShortcuts(props.moves, props.events, 'dlit');

    _this.state = {
      showDebugUI: true,
      showLog: false,
      showGameInfo: props.showGameInfo,
      dockControls: props.dockControls,
      help: false,
      AIMetadata: null
    };
    return _this;
  }

  createClass(Debug, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      Mousetrap.bind('d', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { showDebugUI: !old.showDebugUI };
        });
      });

      Mousetrap.bind('l', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { showLog: !old.showLog };
        });
      });

      Mousetrap.bind('i', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { showGameInfo: !old.showGameInfo };
        });
      });

      Mousetrap.bind('t', function (e) {
        e.preventDefault();
        _this2.setState(function (old) {
          return { dockControls: !old.dockControls };
        });
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      Mousetrap.unbind('d');
      Mousetrap.unbind('l');
    }
  }, {
    key: 'render',
    value: function render() {
      if (!this.state.showDebugUI) {
        return null;
      }

      var moves = [];
      for (var name in this.props.moves) {
        var fn = this.props.moves[name];
        var shortcut = this.shortcuts[name];
        moves.push(React.createElement(DebugMove, { key: name, name: name, fn: fn, shortcut: shortcut }));
      }

      var events = [];
      for (var _name in this.props.events) {
        var _fn = this.props.events[_name];
        var _shortcut = this.shortcuts[_name];
        events.push(React.createElement(DebugMove, { key: _name, name: _name, fn: _fn, shortcut: _shortcut }));
      }

      var visualizeAI = this.state.AIMetadata && this.props.visualizeAI;
      var className = 'debug-ui';

      if (this.state.dockControls) {
        className += ' docktop';
      }

      return React.createElement(
        'div',
        { className: className },
        visualizeAI && React.createElement(
          'div',
          { className: 'ai-visualization' },
          this.props.visualizeAI(this.state.AIMetadata)
        ),
        React.createElement(
          'div',
          { className: 'pane' },
          React.createElement(
            'div',
            { className: 'menu' },
            React.createElement(
              'div',
              {
                className: this.state.showLog ? 'item' : 'item active',
                onClick: this.onClickMain
              },
              'Main'
            ),
            React.createElement(
              'div',
              {
                className: this.state.showLog ? 'item active' : 'item',
                onClick: this.onClickLog
              },
              'Log'
            )
          ),
          this.state.showLog || React.createElement(
            'span',
            null,
            this.state.showGameInfo && React.createElement(GameInfo, {
              gameID: this.props.gameID,
              playerID: this.props.playerID,
              isActive: this.props.gamestate.isActive,
              isConnected: this.props.gamestate.isConnected,
              isMultiplayer: this.props.isMultiplayer
            }),
            React.createElement(Controls, {
              dockTop: this.state.dockControls,
              help: this.state.help,
              toggleHelp: this.toggleHelp,
              step: this.props.step,
              simulate: this.simulate,
              reset: this.props.reset,
              save: this.saveState,
              restore: this.restoreState
            }),
            React.createElement(
              'h3',
              null,
              'Players'
            ),
            React.createElement(PlayerInfo, {
              ctx: this.props.gamestate.ctx,
              playerID: this.props.playerID,
              onClick: this.props.updatePlayerID
            }),
            React.createElement(
              'h3',
              null,
              'Moves'
            ),
            React.createElement(
              'section',
              null,
              moves
            ),
            React.createElement(
              'h3',
              null,
              'Events'
            ),
            React.createElement(
              'section',
              null,
              events
            ),
            React.createElement(
              'section',
              null,
              React.createElement(
                'pre',
                { className: 'json' },
                React.createElement(
                  'strong',
                  null,
                  'G'
                ),
                ':',
                ' ',
                JSON.stringify(this.props.gamestate.G, null, 2)
              )
            ),
            React.createElement(
              'section',
              null,
              React.createElement(
                'pre',
                { className: 'json' },
                React.createElement(
                  'strong',
                  null,
                  'ctx'
                ),
                ':',
                ' ',
                JSON.stringify(SanitizeCtx(this.props.gamestate.ctx), null, 2)
              )
            )
          ),
          this.state.showLog && React.createElement(
            'section',
            null,
            React.createElement(GameLog, {
              onHover: this.onLogHover,
              reducer: this.props.reducer,
              log: this.props.gamestate.log,
              initialState: this.props.gamestate._initial
            })
          )
        )
      );
    }
  }]);
  return Debug;
}(React.Component);
Debug.propTypes = {
  gamestate: PropTypes.shape({
    G: PropTypes.any.isRequired,
    ctx: PropTypes.any.isRequired,
    log: PropTypes.array.isRequired,
    isActive: PropTypes.bool,
    isConnected: PropTypes.bool,
    _initial: PropTypes.any.isRequired
  }),
  gameID: PropTypes.string.isRequired,
  playerID: PropTypes.string,
  isMultiplayer: PropTypes.bool,
  moves: PropTypes.any,
  events: PropTypes.any,
  restore: PropTypes.func,
  showLog: PropTypes.bool,
  store: PropTypes.any,
  step: PropTypes.func,
  reset: PropTypes.func,
  reducer: PropTypes.func,
  overrideGameState: PropTypes.func,
  visualizeAI: PropTypes.func,
  updateGameID: PropTypes.func,
  updatePlayerID: PropTypes.func,
  updateCredentials: PropTypes.func,
  showGameInfo: PropTypes.bool,
  dockControls: PropTypes.bool
};
Debug.defaultProps = {
  showGameInfo: true,
  dockControls: false
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

// The actions that are sent across the network.
var blacklistedActions = new Set([RESTORE]);

/**
 * Multiplayer
 *
 * Handles all the multiplayer interactions on the client-side.
 */
var Multiplayer = function () {
  /**
   * Creates a new Mutiplayer instance.
   * @param {object} socket - Override for unit tests.
   * @param {object} socketOpts - Options to pass to socket.io.
   * @param {string} gameID - The game ID to connect to.
   * @param {string} playerID - The player ID associated with this client.
   * @param {string} gameName - The game type (the `name` field in `Game`).
   * @param {string} numPlayers - The number of players.
   * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.
   */
  function Multiplayer() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        socket = _ref.socket,
        socketOpts = _ref.socketOpts,
        gameID = _ref.gameID,
        playerID = _ref.playerID,
        gameName = _ref.gameName,
        numPlayers = _ref.numPlayers,
        server = _ref.server;

    classCallCheck(this, Multiplayer);

    this.server = server;
    this.socket = socket;
    this.socketOpts = socketOpts;
    this.gameName = gameName || 'default';
    this.gameID = gameID || 'default';
    this.playerID = playerID || null;
    this.numPlayers = numPlayers || 2;
    this.gameID = this.gameName + ':' + this.gameID;
    this.isConnected = false;
    this.callback = function () {};
  }

  /**
   * Creates a Redux store with some middleware that sends actions
   * to the server whenever they are dispatched.
   * @param {function} reducer - The game reducer.
   * @param {function} enhancer - optional enhancer to apply to Redux store
   */


  createClass(Multiplayer, [{
    key: 'createStore',
    value: function createStore$$1(reducer, enhancer) {
      var _this = this;

      this.store = null;

      // Redux middleware to emit a message on a socket
      // whenever an action is dispatched.
      var SocketEnhancer = redux.applyMiddleware(function (_ref2) {
        var getState = _ref2.getState;
        return function (next) {
          return function (action) {
            var state = getState();
            var result = next(action);

            if (!blacklistedActions.has(action.type) && action._remote != true) {
              _this.socket.emit('action', action, state._stateID, _this.gameID, _this.playerID);
            }

            return result;
          };
        };
      });

      enhancer = enhancer ? redux.compose(enhancer, SocketEnhancer) : SocketEnhancer;
      this.store = redux.createStore(reducer, enhancer);

      return this.store;
    }

    /**
     * Connect to the server.
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (!this.socket) {
        if (this.server) {
          var server = this.server;
          if (server.search(/^https?:\/\//) == -1) {
            server = 'http://' + this.server;
          }

          this.socket = io(server + '/' + this.gameName, this.socketOpts);
        } else {
          this.socket = io('/' + this.gameName, this.socketOpts);
        }
      }

      this.socket.on('sync', function (gameID, state) {
        if (gameID == _this2.gameID && state._stateID >= _this2.store.getState()._stateID) {
          var action = restore(state);
          action._remote = true;
          _this2.store.dispatch(action);
        }
      });

      // Initial sync to get game state.
      this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);

      // Keep track of connection status.
      this.socket.on('connect', function () {
        _this2.isConnected = true;
        _this2.callback();
      });
      this.socket.on('disconnect', function () {
        _this2.isConnected = false;
        _this2.callback();
      });
    }

    /**
     * Subscribe to connection state changes.
     */

  }, {
    key: 'subscribe',
    value: function subscribe(fn) {
      this.callback = fn;
    }

    /**
     * Updates the game id.
     * @param {string} id - The new game id.
     */

  }, {
    key: 'updateGameID',
    value: function updateGameID(id) {
      this.gameID = this.gameName + ':' + id;

      var action = reset();
      action._remote = true;
      this.store.dispatch(action);

      if (this.socket) {
        this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);
      }
    }

    /**
     * Updates the player associated with this client.
     * @param {string} id - The new player id.
     */

  }, {
    key: 'updatePlayerID',
    value: function updatePlayerID(id) {
      this.playerID = id;

      var action = reset();
      action._remote = true;
      this.store.dispatch(action);

      if (this.socket) {
        this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);
      }
    }
  }]);
  return Multiplayer;
}();

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) {
    me.s0 += 1;
  }
  me.s1 -= mash(seed);
  if (me.s1 < 0) {
    me.s1 += 1;
  }
  me.s2 -= mash(seed);
  if (me.s2 < 0) {
    me.s2 += 1;
  }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;
  if (state) {
    if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) == 'object') copy(state, xg);
    prng.state = function () {
      return copy(xg, {});
    };
  }
  return prng;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */
var Random = function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(ctx) {
    classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = ctx._random || { seed: '0' };
  }

  /**
   * Updates ctx with the PRNG state.
   * @param {object} ctx - The ctx object to update.
   */


  createClass(Random, [{
    key: 'update',
    value: function update(ctx) {
      return _extends({}, ctx, { _random: this.state });
    }

    /**
     * Attaches the Random API to ctx.
     * @param {object} ctx - The ctx object to attach to.
     */

  }, {
    key: 'attach',
    value: function attach(ctx) {
      return _extends({}, ctx, { random: this._api() });
    }

    /**
     * Generate a random number.
     */

  }, {
    key: '_random',
    value: function _random() {
      var R = this.state;

      var fn = void 0;
      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, { state: true });
      } else {
        fn = new alea('', { state: R.prngstate });
      }

      var number = fn();

      this.state = _extends({}, R, {
        prngstate: fn.state()
      });

      return number;
    }
  }, {
    key: '_api',
    value: function _api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      };

      // Generate functions for predefined dice values D4 - D20.
      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];
        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _extends({}, predefined, {

        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        }
      });
    }
  }]);
  return Random;
}();

/**
 * Removes the attached Random api from ctx.
 *
 * @param {object} ctx - The ctx object with the Random API attached.
 * @returns {object} A plain ctx object without the Random API.
 */
Random.detach = function (ctx) {
  var random = ctx.random,
      rest = objectWithoutProperties(ctx, ['random']); // eslint-disable-line no-unused-vars

  return rest;
};

/**
 * Generates a new seed from the current date / time.
 */
Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Events
 */
var Events = function () {
  function Events(flow, playerID) {
    classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }

  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  createClass(Events, [{
    key: 'attach',
    value: function attach(ctx) {
      var _this = this;

      var events = {};

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({ key: key, args: args });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _extends({}, ctx, { events: events });
    }

    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: 'update',
    value: function update(state) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.dispatch[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var action = automaticGameEvent(item.key, item.args, this.playerID);
          state = _extends({}, state, this.flow.processGameEvent(state, action));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return state;
    }
  }]);
  return Events;
}();

/**
 * Detaches the Events API from ctx.
 * @param {object} ctx - The ctx object to strip.
 */
Events.detach = function (ctx) {
  var events = ctx.events,
      rest = objectWithoutProperties(ctx, ['events']); // eslint-disable-line no-unused-vars

  return rest;
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 * @param {...object} game - Return value of Game().
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true if we are in a multiplayer client.
 */
function CreateGameReducer(_ref) {
  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      multiplayer = _ref.multiplayer;

  if (!numPlayers) {
    numPlayers = 2;
  }

  var ctx = game.flow.ctx(numPlayers);

  var seed = game.seed;
  if (seed === undefined) {
    seed = Random.seed();
  }
  ctx._random = { seed: seed };

  var random = new Random(ctx);
  var ctxWithAPI = random.attach(ctx);

  var initial = {
    // User managed state.
    G: game.setup(ctxWithAPI),

    // Framework managed state.
    ctx: ctx,

    // A list of actions performed so far. Used by the
    // GameLog to display a journal of moves.
    log: [],

    // List of {G, ctx} pairs that can be undone.
    _undo: [],

    // List of {G, ctx} pairs that can be redone.
    _redo: [],

    // A monotonically non-decreasing ID to ensure that
    // state updates are only allowed from clients that
    // are at the same version that the server.
    _stateID: 0,

    // A snapshot of this object so that actions can be
    // replayed over it to view old snapshots.
    _initial: {}
  };

  var events = new Events(game.flow, ctx.currentPlayer);
  ctxWithAPI = events.attach(ctxWithAPI);

  var state = game.flow.init({ G: initial.G, ctx: ctxWithAPI });

  var _events$update = events.update(state),
      ctxWithEvents = _events$update.ctx;

  initial.G = state.G;
  initial._undo = state._undo;
  initial.ctx = ctxWithEvents;
  initial.ctx = random.update(initial.ctx);
  initial.ctx = Random.detach(initial.ctx);
  initial.ctx = Events.detach(initial.ctx);

  var deepCopy = function deepCopy(obj) {
    return flatted.parse(flatted.stringify(obj));
  };
  initial._initial = deepCopy(initial);

  /**
   * GameReducer
   *
   * Redux reducer that maintains the overall game state.
   * @param {object} state - The state before the action.
   * @param {object} action - A Redux action.
   */
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initial;
    var action = arguments[1];

    switch (action.type) {
      case GAME_EVENT:
        {
          // Process game events only on the server.
          // These events like `endTurn` typically
          // contain code that may rely on secret state
          // and cannot be computed on the client.
          if (multiplayer) {
            return state;
          }

          // Ignore the event if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerCallEvent(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random = new Random(state.ctx);
          // Initialize Events API.
          var _events = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          state = _extends({}, state, { ctx: _random.attach(state.ctx) });
          // Attach Events API to ctx.
          state = _extends({}, state, { ctx: _events.attach(state.ctx) });

          // Update state.
          var newState = game.flow.processGameEvent(state, action);
          // Trigger any events that were called via the Events API.
          newState = _events.update(newState);
          // Update ctx with PRNG state.
          var _ctx = _random.update(newState.ctx);
          // Detach Random API from ctx.
          _ctx = Random.detach(_ctx);
          // Detach Events API from ctx.
          _ctx = Events.detach(_ctx);

          return _extends({}, newState, { ctx: _ctx, _stateID: state._stateID + 1 });
        }

      case MAKE_MOVE:
        {
          // Check whether the game knows the move at all.
          if (!game.moveNames.includes(action.payload.type)) {
            return state;
          }

          // Ignore the move if it isn't allowed at this point.
          if (!game.flow.canMakeMove(state.G, state.ctx, action.payload.type)) {
            return state;
          }

          // Ignore the move if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerMakeMove(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random2 = new Random(state.ctx);
          // Initialize Events API.
          var _events2 = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          var _ctxWithAPI = _random2.attach(state.ctx);
          // Attach Events API to ctx.
          _ctxWithAPI = _events2.attach(_ctxWithAPI);

          // Process the move.
          var G = game.processMove(state.G, action.payload, _ctxWithAPI);
          if (G === undefined) {
            // the game declared the move as invalid.
            return state;
          }

          // Update ctx with PRNG state.
          var _ctx2 = _random2.update(state.ctx);
          // Detach Random API from ctx.
          _ctx2 = Random.detach(_ctx2);
          // Detach Events API from ctx.
          _ctx2 = Events.detach(_ctx2);

          // Undo changes to G if the move should not run on the client.
          if (multiplayer && !game.flow.optimisticUpdate(G, _ctx2, action.payload)) {
            G = state.G;
          }

          var log = [].concat(toConsumableArray(state.log), [action]);
          state = _extends({}, state, { G: G, ctx: _ctx2, log: log, _stateID: state._stateID + 1 });

          // If we're on the client, just process the move
          // and no triggers in multiplayer mode.
          // These will be processed on the server, which
          // will send back a state update.
          if (multiplayer) {
            return state;
          }

          // Allow the flow reducer to process any triggers that happen after moves.
          state = _extends({}, state, { ctx: _random2.attach(state.ctx) });
          state = _extends({}, state, { ctx: _events2.attach(state.ctx) });
          state = game.flow.processMove(state, action.payload);
          state = _events2.update(state);
          state = _extends({}, state, { ctx: _random2.update(state.ctx) });
          state = _extends({}, state, { ctx: Random.detach(state.ctx) });
          state = _extends({}, state, { ctx: Events.detach(state.ctx) });

          return state;
        }

      case RESTORE:
        {
          return action.state;
        }

      case RESET:
        {
          return initial;
        }

      case UNDO:
        {
          var _state = state,
              _undo = _state._undo,
              _redo = _state._redo;


          if (_undo.length < 2) {
            return state;
          }

          var last = _undo[_undo.length - 1];
          var restore = _undo[_undo.length - 2];

          // Only allow undoable moves to be undone.
          if (!game.flow.canUndoMove(state.G, state.ctx, last.moveType)) {
            return state;
          }

          return _extends({}, state, {
            G: restore.G,
            ctx: restore.ctx,
            _undo: _undo.slice(0, _undo.length - 1),
            _redo: [last].concat(toConsumableArray(_redo))
          });
        }

      case REDO:
        {
          var _state2 = state,
              _undo2 = _state2._undo,
              _redo2 = _state2._redo;


          if (_redo2.length == 0) {
            return state;
          }

          var first = _redo2[0];

          return _extends({}, state, {
            G: first.G,
            ctx: first.ctx,
            _undo: [].concat(toConsumableArray(_undo2), [first]),
            _redo: _redo2.slice(1)
          });
        }

      default:
        {
          return state;
        }
    }
  };
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * createDispatchers
 *
 * Create action dispatcher wrappers with bound playerID and credentials
 */
function createDispatchers(storeActionType, innerActionNames, store, playerID, credentials, multiplayer) {
  return innerActionNames.reduce(function (dispatchers, name) {
    dispatchers[name] = function () {
      var assumedPlayerID = playerID;

      // In singleplayer mode, if the client does not have a playerID
      // associated with it, we attach the currentPlayer as playerID.
      if (!multiplayer && (playerID === null || playerID === undefined)) {
        var state = store.getState();
        assumedPlayerID = state.ctx.currentPlayer;
      }

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      store.dispatch(ActionCreators[storeActionType](name, args, assumedPlayerID, credentials));
    };
    return dispatchers;
  }, {});
}

/**
 * createEventDispatchers
 *
 * Creates a set of dispatchers to dispatch game flow events.
 * @param {Array} eventNames - A list of event names.
 * @param {object} store - The Redux store to create dispatchers for.
 * @param {string} playerID - The ID of the player dispatching these events.
 * @param {string} credentials - A key indicating that the player is authorized to play.
 */
var createEventDispatchers = createDispatchers.bind(null, 'gameEvent');

/**
 * createMoveDispatchers
 *
 * Creates a set of dispatchers to make moves.
 * @param {Array} moveNames - A list of move names.
 * @param {object} store - The Redux store to create dispatchers for.
 * @param {string} playerID - The ID of the player dispatching these events.
 * @param {string} credentials - A key indicating that the player is authorized to play.
 */
var createMoveDispatchers = createDispatchers.bind(null, 'makeMove');

/**
 * Implementation of Client (see below).
 */

var _ClientImpl = function () {
  function _ClientImpl(_ref) {
    var _this = this;

    var game = _ref.game,
        ai = _ref.ai,
        numPlayers = _ref.numPlayers,
        multiplayer = _ref.multiplayer,
        socketOpts = _ref.socketOpts,
        gameID = _ref.gameID,
        playerID = _ref.playerID,
        credentials = _ref.credentials,
        enhancer = _ref.enhancer;
    classCallCheck(this, _ClientImpl);

    this.game = game;
    this.playerID = playerID;
    this.gameID = gameID;
    this.credentials = credentials;

    var server = undefined;
    if (multiplayer instanceof Object && 'server' in multiplayer) {
      server = multiplayer.server;
      multiplayer = true;
    }

    this.multiplayer = multiplayer;

    this.reducer = CreateGameReducer({
      game: game,
      numPlayers: numPlayers,
      multiplayer: multiplayer
    });

    if (ai !== undefined && multiplayer === undefined) {
      var bot = new ai.bot({ game: game, enumerate: ai.enumerate });

      this.step = function () {
        var state = _this.store.getState();
        var playerID = state.ctx.actionPlayers[0];

        var _bot$play = bot.play(state, playerID),
            action = _bot$play.action,
            metadata = _bot$play.metadata;

        if (action) {
          action.payload.metadata = metadata;
          _this.store.dispatch(action);
        }

        return action;
      };
    }

    this.reset = function () {
      _this.store.dispatch(reset());
    };
    this.undo = function () {
      _this.store.dispatch(undo());
    };
    this.redo = function () {
      _this.store.dispatch(redo());
    };

    this.store = null;

    if (multiplayer) {
      this.multiplayerClient = new Multiplayer({
        gameID: gameID,
        playerID: playerID,
        gameName: game.name,
        numPlayers: numPlayers,
        server: server,
        socketOpts: socketOpts
      });
      this.store = this.multiplayerClient.createStore(this.reducer, enhancer);
    } else {
      this.store = redux.createStore(this.reducer, enhancer);

      // If no playerID was provided, set it to undefined.
      if (this.playerID === null) {
        this.playerID = undefined;
      }
    }

    this.createDispatchers();
  }

  createClass(_ClientImpl, [{
    key: 'subscribe',
    value: function subscribe(fn) {
      this.store.subscribe(fn);

      if (this.multiplayerClient) {
        this.multiplayerClient.subscribe(fn);
      }
    }
  }, {
    key: 'getState',
    value: function getState() {
      var state = this.store.getState();

      // isActive.

      var isActive = true;

      var canPlayerMakeMove = this.game.flow.canPlayerMakeMove(state.G, state.ctx, this.playerID);

      if (this.multiplayer && !canPlayerMakeMove) {
        isActive = false;
      }

      if (!this.multiplayer && this.playerID !== null && this.playerID !== undefined && !canPlayerMakeMove) {
        isActive = false;
      }

      if (state.ctx.gameover !== undefined) {
        isActive = false;
      }

      // Secrets are normally stripped on the server,
      // but we also strip them here so that game developers
      // can see their effects while prototyping.
      var G = this.game.playerView(state.G, state.ctx, this.playerID);

      // Combine into return value.
      var ret = _extends({}, state, { isActive: isActive, G: G });

      if (this.multiplayerClient) {
        var isConnected = this.multiplayerClient.isConnected;
        ret = _extends({}, ret, { isConnected: isConnected });
      }

      return ret;
    }
  }, {
    key: 'connect',
    value: function connect() {
      if (this.multiplayerClient) {
        this.multiplayerClient.connect();
      }
    }
  }, {
    key: 'createDispatchers',
    value: function createDispatchers() {
      this.moves = createMoveDispatchers(this.game.moveNames, this.store, this.playerID, this.credentials, this.multiplayer);

      this.events = createEventDispatchers(this.game.flow.eventNames, this.store, this.playerID, this.credentials, this.multiplayer);
    }
  }, {
    key: 'updatePlayerID',
    value: function updatePlayerID(playerID) {
      this.playerID = playerID;
      this.createDispatchers();

      if (this.multiplayerClient) {
        this.multiplayerClient.updatePlayerID(playerID);
      }
    }
  }, {
    key: 'updateGameID',
    value: function updateGameID(gameID) {
      this.gameID = gameID;
      this.createDispatchers();

      if (this.multiplayerClient) {
        this.multiplayerClient.updateGameID(gameID);
      }
    }
  }, {
    key: 'updateCredentials',
    value: function updateCredentials(credentials) {
      this.credentials = credentials;
      this.createDispatchers();
    }
  }]);
  return _ClientImpl;
}();

/**
 * Client
 *
 * boardgame.io JS client.
 *
 * @param {...object} game - The return value of `Game`.
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }
 *                                  to make a multiplayer client. The second
 *                                  syntax specifies a non-default socket server.
 * @param {...object} socketOpts - Options to pass to socket.io.
 * @param {...object} gameID - The gameID that you want to connect to.
 * @param {...object} playerID - The playerID associated with this client.
 * @param {...string} credentials - The authentication credentials associated with this client.
 *
 * Returns:
 *   A JS object that provides an API to interact with the
 *   game by dispatching moves and events.
 */


function Client$1(opts) {
  return new _ClientImpl(opts);
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Client
 *
 * boardgame.io React client.
 *
 * @param {...object} game - The return value of `Game`.
 * @param {...object} numPlayers - The number of players.
 * @param {...object} board - The React component for the game.
 * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }
 *                                  to make a multiplayer client. The second
 *                                  syntax specifies a non-default socket server.
 * @param {...object} debug - Enables the Debug UI.
 * @param {...object} enhancer - Optional enhancer to send to the Redux store
 *
 * Returns:
 *   A React component that wraps board and provides an
 *   API through props for it to interact with the framework
 *   and dispatch actions such as MAKE_MOVE, GAME_EVENT, RESET,
 *   UNDO and REDO.
 */
function Client$$1(_ref) {
  var _class, _temp;

  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      board = _ref.board,
      multiplayer = _ref.multiplayer,
      ai = _ref.ai,
      debug = _ref.debug,
      enhancer = _ref.enhancer;

  if (debug === undefined) debug = true;

  /*
   * WrappedBoard
   *
   * The main React component that wraps the passed in
   * board component and adds the API to its props.
   */
  return _temp = _class = function (_React$Component) {
    inherits(WrappedBoard, _React$Component);

    function WrappedBoard(props) {
      classCallCheck(this, WrappedBoard);

      var _this = possibleConstructorReturn(this, (WrappedBoard.__proto__ || Object.getPrototypeOf(WrappedBoard)).call(this, props));

      _this.state = {
        gameStateOverride: null
      };

      _this.updateGameID = function (gameID) {
        _this.client.updateGameID(gameID);
        _this.gameID = gameID;
        _this.forceUpdate();
      };

      _this.updatePlayerID = function (playerID) {
        _this.client.updatePlayerID(playerID);
        _this.playerID = playerID;
        _this.forceUpdate();
      };

      _this.updateCredentials = function (credentials) {
        _this.client.updateCredentials(credentials);
        _this.credentials = credentials;
        _this.forceUpdate();
      };

      _this.overrideGameState = function (state) {
        _this.setState({ gameStateOverride: state });
      };

      _this.client = Client$1({
        game: game,
        ai: ai,
        numPlayers: numPlayers,
        multiplayer: multiplayer,
        gameID: props.gameID,
        playerID: props.playerID,
        credentials: props.credentials,
        enhancer: enhancer
      });

      _this.gameID = props.gameID;
      _this.playerID = props.playerID;
      _this.credentials = props.credentials;

      _this.client.subscribe(function () {
        return _this.forceUpdate();
      });
      return _this;
    }

    createClass(WrappedBoard, [{
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        if (this.props.gameID != prevProps.gameID) {
          this.updateGameID(this.props.gameID);
        }
        if (this.props.playerID != prevProps.playerID) {
          this.updatePlayerID(this.props.playerID);
        }
        if (this.props.credentials != prevProps.credentials) {
          this.updateCredentials(this.props.credentials);
        }
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.client.connect();
      }
    }, {
      key: 'render',
      value: function render() {
        var _board = null;
        var _debug = null;

        var state = this.client.getState();
        var _props = this.props,
            debugProp = _props.debug,
            rest = objectWithoutProperties(_props, ['debug']);


        if (this.state.gameStateOverride) {
          state = _extends({}, state, this.state.gameStateOverride);
        }

        if (board) {
          _board = React.createElement(board, _extends({}, state, rest, {
            isMultiplayer: multiplayer !== undefined,
            moves: this.client.moves,
            events: this.client.events,
            gameID: this.gameID,
            playerID: this.playerID,
            reset: this.client.reset,
            undo: this.client.undo,
            redo: this.client.redo
          }));
        }

        if (debug !== false && debugProp) {
          var showGameInfo = (typeof debug === 'undefined' ? 'undefined' : _typeof(debug)) === 'object' && debug.showGameInfo;
          var dockControls = (typeof debug === 'undefined' ? 'undefined' : _typeof(debug)) === 'object' && debug.dockControls;
          _debug = React.createElement(Debug, {
            gamestate: state,
            reducer: this.client.reducer,
            store: this.client.store,
            isMultiplayer: multiplayer !== undefined,
            moves: this.client.moves,
            events: this.client.events,
            gameID: this.gameID,
            playerID: this.playerID,
            credentials: this.credentials,
            step: this.client.step,
            reset: this.client.reset,
            undo: this.client.undo,
            redo: this.client.redo,
            visualizeAI: ai && ai.visualize,
            overrideGameState: this.overrideGameState,
            updateGameID: this.updateGameID,
            updatePlayerID: this.updatePlayerID,
            updateCredentials: this.updateCredentials,
            showGameInfo: showGameInfo,
            dockControls: dockControls
          });
        }

        return React.createElement(
          'div',
          { className: 'client' },
          React.createElement(
            'span',
            null,
            _debug,
            _board
          )
        );
      }
    }]);
    return WrappedBoard;
  }(React.Component), _class.propTypes = {
    // The ID of a game to connect to.
    // Only relevant in multiplayer.
    gameID: PropTypes.string,
    // The ID of the player associated with this client.
    // Only relevant in multiplayer.
    playerID: PropTypes.string,
    // This client's authentication credentials.
    // Only relevant in multiplayer.
    credentials: PropTypes.string,
    // Enable / disable the Debug UI.
    debug: PropTypes.any
  }, _class.defaultProps = {
    gameID: 'default',
    playerID: null,
    credentials: null,
    debug: true
  }, _temp;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

exports.Client = Client$$1;
exports.Debug = Debug;

Object.defineProperty(exports, '__esModule', { value: true });

})));
