'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};













var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};





















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * InMemory data storage.
 */
var InMemory = function () {
  /**
   * Creates a new InMemory storage.
   */
  function InMemory() {
    classCallCheck(this, InMemory);

    this.games = new Map();
  }

  /**
   * Connect.
   * No-op for the InMemory instance.
   */


  createClass(InMemory, [{
    key: "connect",
    value: async function connect() {
      return;
    }

    /**
     * Write the game state to the in-memory object.
     * @param {string} id - The game id.
     * @param {object} store - A game state to persist.
     */

  }, {
    key: "set",
    value: async function set$$1(id, state) {
      return await this.games.set(id, state);
    }

    /**
     * Read the game state from the in-memory object.
     * @param {string} id - The game id.
     * @returns {object} - A game state, or undefined
     *                     if no game is found with this id.
     */

  }, {
    key: "get",
    value: async function get$$1(id) {
      return await this.games.get(id);
    }

    /**
     * Check if a particular game id exists.
     * @param {string} id - The game id.
     * @returns {boolean} - True if a game with this id exists.
     */

  }, {
    key: "has",
    value: async function has(id) {
      return await this.games.has(id);
    }
  }]);
  return InMemory;
}();

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var LRU = require('lru-cache');

/**
 * MongoDB connector.
 */
var Mongo = function () {
  /**
   * Creates a new Mongo connector object.
   */
  function Mongo(_ref) {
    var url = _ref.url,
        dbname = _ref.dbname,
        cacheSize = _ref.cacheSize,
        mockClient = _ref.mockClient;
    classCallCheck(this, Mongo);

    if (cacheSize === undefined) cacheSize = 1000;
    if (dbname === undefined) dbname = 'bgio';

    this.client = mockClient || require('mongodb').MongoClient;
    this.url = url;
    this.dbname = dbname;
    this.cache = new LRU({ max: cacheSize });
  }

  /**
   * Connect to the instance.
   */


  createClass(Mongo, [{
    key: 'connect',
    value: async function connect() {
      var c = await this.client.connect(this.url);
      this.db = c.db(this.dbname);
      return;
    }

    /**
     * Write the game state.
     * @param {string} id - The game id.
     * @param {object} store - A game state to persist.
     */

  }, {
    key: 'set',
    value: async function set$$1(id, state) {
      // Don't set a value if the cache has a more recent version.
      // This can occur due a race condition.
      //
      // For example:
      //
      // A --sync--> server | DB => 0 --+
      //                                |
      // A <--sync-- server | DB => 0 --+
      //
      // B --sync--> server | DB => 0 ----+
      //                                  |
      // A --move--> server | DB <= 1 --+ |
      //                                | |
      // A <--sync-- server | DB => 1 --+ |
      //                                  |
      // B <--sync-- server | DB => 0 ----+
      //
      var cacheValue = this.cache.get(id);
      if (cacheValue && cacheValue._stateID >= state._stateID) {
        return;
      }

      this.cache.set(id, state);

      var col = this.db.collection(id);
      delete state._id;
      await col.insert(state);

      return;
    }

    /**
     * Read the game state.
     * @param {string} id - The game id.
     * @returns {object} - A game state, or undefined
     *                     if no game is found with this id.
     */

  }, {
    key: 'get',
    value: async function get$$1(id) {
      var cacheValue = this.cache.get(id);
      if (cacheValue !== undefined) {
        return cacheValue;
      }

      var col = this.db.collection(id);
      var docs = await col.find().sort({ _id: -1 }).limit(1).toArray();

      var oldStateID = 0;
      cacheValue = this.cache.get(id);
      /* istanbul ignore next line */
      if (cacheValue !== undefined) {
        /* istanbul ignore next line */
        oldStateID = cacheValue._stateID;
      }

      var newStateID = -1;
      if (docs.length > 0) {
        newStateID = docs[0]._stateID;
      }

      // Update the cache, but only if the read
      // value is newer than the value already in it.
      // A race condition might overwrite the
      // cache with an older value, so we need this.
      if (newStateID >= oldStateID) {
        this.cache.set(id, docs[0]);
      }

      return docs[0];
    }

    /**
     * Check if a particular game exists.
     * @param {string} id - The game id.
     * @returns {boolean} - True if a game with this id exists.
     */

  }, {
    key: 'has',
    value: async function has(id) {
      var cacheValue = this.cache.get(id);
      if (cacheValue !== undefined) {
        return true;
      }

      var col = this.db.collection(id);
      var docs = await col.find().limit(1).toArray();
      return docs.length > 0;
    }
  }]);
  return Mongo;
}();

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var LRU$1 = require('lru-cache');

var ENGINE_FIRESTORE = 'Firestore';
var ENGINE_RTDB = 'RTDB';

/**
 * Firebase RTDB/Firestore connector.
 */
var Firebase = function () {
  /**
   * Creates a new Firebase connector object.
   * The default engine is Firestore.
   * @constructor
   */
  function Firebase(_ref) {
    var config = _ref.config,
        dbname = _ref.dbname,
        engine = _ref.engine,
        cacheSize = _ref.cacheSize;
    classCallCheck(this, Firebase);

    if (cacheSize === undefined) {
      cacheSize = 1000;
    }

    if (dbname === undefined) {
      dbname = 'bgio';
    }

    // // TODO: better handling for possible errors
    if (config === undefined) {
      config = {};
    }

    this.client = require('firebase');
    this.engine = engine === ENGINE_RTDB ? engine : ENGINE_FIRESTORE;
    this.config = config;
    this.dbname = dbname;
    this.cache = new LRU$1({ max: cacheSize });
  }

  /**
   * Connect to the instance.
   */


  createClass(Firebase, [{
    key: 'connect',
    value: async function connect() {
      this.client.initializeApp(this.config);
      this.db = this.engine === ENGINE_FIRESTORE ? this.client.firestore() : this.client.database().ref();
      return;
    }

    /**
     * Write the game state.
     * @param {string} id - The game id.
     * @param {object} store - A game state to persist.
     */

  }, {
    key: 'set',
    value: async function set$$1(id, state) {
      var cacheValue = this.cache.get(id);
      if (cacheValue && cacheValue._stateID >= state._stateID) {
        return;
      }

      this.cache.set(id, state);

      var col = this.engine === ENGINE_RTDB ? this.db.child(id) : this.db.collection(this.dbname).doc(id);
      delete state._id;
      await col.set(state);

      return;
    }

    /**
     * Read the game state.
     * @param {string} id - The game id.
     * @returns {object} - A game state, or undefined
     *                     if no game is found with this id.
     */

  }, {
    key: 'get',
    value: async function get$$1(id) {
      var cacheValue = this.cache.get(id);
      if (cacheValue !== undefined) {
        return cacheValue;
      }

      var col = void 0,
          doc = void 0,
          data = void 0;
      if (this.engine === ENGINE_RTDB) {
        col = this.db.child(id);
        data = await col.once('value');
        doc = data.val() ? Object.assign({}, data.val(), { _id: id }) : data.val();
      } else {
        col = this.db.collection(this.dbname).doc(id);
        data = await col.get();
        doc = data.data() ? Object.assign({}, data.data(), { _id: id }) : data.data();
      }

      var oldStateID = 0;
      cacheValue = this.cache.get(id);
      /* istanbul ignore next line */
      if (cacheValue !== undefined) {
        /* istanbul ignore next line */
        oldStateID = cacheValue._stateID;
      }

      var newStateID = -1;
      if (doc) {
        newStateID = doc._stateID;
      }

      // Update the cache, but only if the read
      // value is newer than the value already in it.
      // A race condition might overwrite the
      // cache with an older value, so we need this.
      if (newStateID >= oldStateID) {
        this.cache.set(id, doc);
      }

      return doc;
    }

    /**
     * Check if a particular game exists.
     * @param {string} id - The game id.
     * @returns {boolean} - True if a game with this id exists.
     */

  }, {
    key: 'has',
    value: async function has(id) {
      var cacheValue = this.cache.get(id);
      if (cacheValue !== undefined) {
        return true;
      }

      var col = void 0,
          data = void 0,
          exists = void 0;
      if (this.engine === ENGINE_RTDB) {
        col = this.db.child(id);
        data = await col.once('value');
        exists = data.exists();
      } else {
        col = this.db.collection(this.dbname).doc(id);
        data = await col.get();
        exists = data.exists;
      }

      return exists;
    }
  }]);
  return Firebase;
}();

var DBFromEnv = function DBFromEnv() {
  if (process.env.MONGO_URI) {
    return new Mongo({ url: process.env.MONGO_URI });
  } else if (process.env.FIREBASE_APIKEY && process.env.FIREBASE_AUTHDOMAIN && process.env.FIREBASE_DATABASEURL && process.env.FIREBASE_PROJECTID) {
    var config = {
      apiKey: process.env.FIREBASE_APIKEY,
      authDomain: process.env.FIREBASE_AUTHDOMAIN,
      databaseURL: process.env.FIREBASE_DATABASEURL,
      projectId: process.env.FIREBASE_PROJECTID
    };
    return new Firebase({ config: config, engine: process.env.FIREBASE_ENGINE });
  } else {
    return new InMemory();
  }
};

var Flatted = (function (Primitive, primitive) {

  /*!
   * ISC License
   *
   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
   * PERFORMANCE OF THIS SOFTWARE.
   */

  var Flatted = {

    parse: function parse(text) {
      var input = JSON.parse(text, Primitives).map(primitives);
      var value = input[0];
      return typeof value === 'object' && value ?
              revive(input, new Set, value) : value;
    },

    stringify: function stringify(value) {
      for (var
        firstRun,
        known = new Map,
        input = [],
        output = [],
        i = +set(known, input, value),
        replace = function (key, value) {
          if (firstRun) return (firstRun = !firstRun), value;
          switch (typeof value) {
            case 'object':
              if (value === null) return value;
            case primitive:
              return known.get(value) || set(known, input, value);
          }
          return value;
        };
        i < input.length; i++
      ) {
        firstRun = true;
        output[i] = JSON.stringify(input[i], replace);
      }
      return '[' + output.join(',') + ']';
    }

  };

  return Flatted;

  function revive(input, parsed, output) {
    return Object.keys(output).reduce(
      function (output, key) {
        var value = output[key];
        if (value instanceof Primitive) {
          var tmp = input[value];
          if (typeof tmp === 'object' && !parsed.has(tmp)) {
            parsed.add(tmp);
            output[key] = revive(input, parsed, tmp);
          } else {
            output[key] = tmp;
          }
        }
        return output;
      },
      output
    );
  }

  function set(known, input, value) {
    var index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
  }

  function primitives(value) {
    return value instanceof Primitive ? Primitive(value) : value;
  }

  function Primitives(key, value) {
    return typeof value === primitive ? new Primitive(value) : value;
  }

}(String, 'string'));
const parse = Flatted.parse;
const stringify = Flatted.stringify;

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var MAKE_MOVE = 'MAKE_MOVE';
var GAME_EVENT = 'GAME_EVENT';
var RESTORE = 'RESTORE';
var RESET = 'RESET';
var UNDO = 'UNDO';
var REDO = 'REDO';

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) {
    me.s0 += 1;
  }
  me.s1 -= mash(seed);
  if (me.s1 < 0) {
    me.s1 += 1;
  }
  me.s2 -= mash(seed);
  if (me.s2 < 0) {
    me.s2 += 1;
  }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;
  if (state) {
    if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) == 'object') copy(state, xg);
    prng.state = function () {
      return copy(xg, {});
    };
  }
  return prng;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */
var Random = function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(ctx) {
    classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = ctx._random || { seed: '0' };
  }

  /**
   * Updates ctx with the PRNG state.
   * @param {object} ctx - The ctx object to update.
   */


  createClass(Random, [{
    key: 'update',
    value: function update(ctx) {
      return _extends({}, ctx, { _random: this.state });
    }

    /**
     * Attaches the Random API to ctx.
     * @param {object} ctx - The ctx object to attach to.
     */

  }, {
    key: 'attach',
    value: function attach(ctx) {
      return _extends({}, ctx, { random: this._api() });
    }

    /**
     * Generate a random number.
     */

  }, {
    key: '_random',
    value: function _random() {
      var R = this.state;

      var fn = void 0;
      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, { state: true });
      } else {
        fn = new alea('', { state: R.prngstate });
      }

      var number = fn();

      this.state = _extends({}, R, {
        prngstate: fn.state()
      });

      return number;
    }
  }, {
    key: '_api',
    value: function _api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      };

      // Generate functions for predefined dice values D4 - D20.
      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];
        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _extends({}, predefined, {

        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return [].concat(toConsumableArray(Array(diceCount).keys())).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        }
      });
    }
  }]);
  return Random;
}();

/**
 * Removes the attached Random api from ctx.
 *
 * @param {object} ctx - The ctx object with the Random API attached.
 * @returns {object} A plain ctx object without the Random API.
 */
Random.detach = function (ctx) {
  var random = ctx.random,
      rest = objectWithoutProperties(ctx, ['random']); // eslint-disable-line no-unused-vars

  return rest;
};

/**
 * Generates a new seed from the current date / time.
 */
Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */


/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */


/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: { type: type, args: args, playerID: playerID, credentials: credentials },
    automatic: true
  };
};

/**
 * Used to reset the Redux store's state.
 * @param {object} state - The state to restore.
 */


/**
 * Used to reset the game state.
 */


/**
 * Used to undo the last move.
 */


/**
 * Used to redo the last undone move.
 */

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * Events
 */
var Events = function () {
  function Events(flow, playerID) {
    classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }

  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  createClass(Events, [{
    key: 'attach',
    value: function attach(ctx) {
      var _this = this;

      var events = {};

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({ key: key, args: args });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _extends({}, ctx, { events: events });
    }

    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: 'update',
    value: function update(state) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.dispatch[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var action = automaticGameEvent(item.key, item.args, this.playerID);
          state = _extends({}, state, this.flow.processGameEvent(state, action));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return state;
    }
  }]);
  return Events;
}();

/**
 * Detaches the Events API from ctx.
 * @param {object} ctx - The ctx object to strip.
 */
Events.detach = function (ctx) {
  var events = ctx.events,
      rest = objectWithoutProperties(ctx, ['events']); // eslint-disable-line no-unused-vars

  return rest;
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 * @param {...object} game - Return value of Game().
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to true if we are in a multiplayer client.
 */
function CreateGameReducer(_ref) {
  var game = _ref.game,
      numPlayers = _ref.numPlayers,
      multiplayer = _ref.multiplayer;

  if (!numPlayers) {
    numPlayers = 2;
  }

  var ctx = game.flow.ctx(numPlayers);

  var seed = game.seed;
  if (seed === undefined) {
    seed = Random.seed();
  }
  ctx._random = { seed: seed };

  var random = new Random(ctx);
  var ctxWithAPI = random.attach(ctx);

  var initial = {
    // User managed state.
    G: game.setup(ctxWithAPI),

    // Framework managed state.
    ctx: ctx,

    // A list of actions performed so far. Used by the
    // GameLog to display a journal of moves.
    log: [],

    // List of {G, ctx} pairs that can be undone.
    _undo: [],

    // List of {G, ctx} pairs that can be redone.
    _redo: [],

    // A monotonically non-decreasing ID to ensure that
    // state updates are only allowed from clients that
    // are at the same version that the server.
    _stateID: 0,

    // A snapshot of this object so that actions can be
    // replayed over it to view old snapshots.
    _initial: {}
  };

  var events = new Events(game.flow, ctx.currentPlayer);
  ctxWithAPI = events.attach(ctxWithAPI);

  var state = game.flow.init({ G: initial.G, ctx: ctxWithAPI });

  var _events$update = events.update(state),
      ctxWithEvents = _events$update.ctx;

  initial.G = state.G;
  initial._undo = state._undo;
  initial.ctx = ctxWithEvents;
  initial.ctx = random.update(initial.ctx);
  initial.ctx = Random.detach(initial.ctx);
  initial.ctx = Events.detach(initial.ctx);

  var deepCopy = function deepCopy(obj) {
    return parse(stringify(obj));
  };
  initial._initial = deepCopy(initial);

  /**
   * GameReducer
   *
   * Redux reducer that maintains the overall game state.
   * @param {object} state - The state before the action.
   * @param {object} action - A Redux action.
   */
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initial;
    var action = arguments[1];

    switch (action.type) {
      case GAME_EVENT:
        {
          // Process game events only on the server.
          // These events like `endTurn` typically
          // contain code that may rely on secret state
          // and cannot be computed on the client.
          if (multiplayer) {
            return state;
          }

          // Ignore the event if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerCallEvent(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random = new Random(state.ctx);
          // Initialize Events API.
          var _events = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          state = _extends({}, state, { ctx: _random.attach(state.ctx) });
          // Attach Events API to ctx.
          state = _extends({}, state, { ctx: _events.attach(state.ctx) });

          // Update state.
          var newState = game.flow.processGameEvent(state, action);
          // Trigger any events that were called via the Events API.
          newState = _events.update(newState);
          // Update ctx with PRNG state.
          var _ctx = _random.update(newState.ctx);
          // Detach Random API from ctx.
          _ctx = Random.detach(_ctx);
          // Detach Events API from ctx.
          _ctx = Events.detach(_ctx);

          return _extends({}, newState, { ctx: _ctx, _stateID: state._stateID + 1 });
        }

      case MAKE_MOVE:
        {
          // Check whether the game knows the move at all.
          if (!game.moveNames.includes(action.payload.type)) {
            return state;
          }

          // Ignore the move if it isn't allowed at this point.
          if (!game.flow.canMakeMove(state.G, state.ctx, action.payload.type)) {
            return state;
          }

          // Ignore the move if the player isn't allowed to make it.
          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerMakeMove(state.G, state.ctx, action.payload.playerID)) {
            return state;
          }

          // Initialize PRNG from ctx.
          var _random2 = new Random(state.ctx);
          // Initialize Events API.
          var _events2 = new Events(game.flow, action.payload.playerID);
          // Attach Random API to ctx.
          var _ctxWithAPI = _random2.attach(state.ctx);
          // Attach Events API to ctx.
          _ctxWithAPI = _events2.attach(_ctxWithAPI);

          // Process the move.
          var G = game.processMove(state.G, action.payload, _ctxWithAPI);
          if (G === undefined) {
            // the game declared the move as invalid.
            return state;
          }

          // Update ctx with PRNG state.
          var _ctx2 = _random2.update(state.ctx);
          // Detach Random API from ctx.
          _ctx2 = Random.detach(_ctx2);
          // Detach Events API from ctx.
          _ctx2 = Events.detach(_ctx2);

          // Undo changes to G if the move should not run on the client.
          if (multiplayer && !game.flow.optimisticUpdate(G, _ctx2, action.payload)) {
            G = state.G;
          }

          var log = [].concat(toConsumableArray(state.log), [action]);
          state = _extends({}, state, { G: G, ctx: _ctx2, log: log, _stateID: state._stateID + 1 });

          // If we're on the client, just process the move
          // and no triggers in multiplayer mode.
          // These will be processed on the server, which
          // will send back a state update.
          if (multiplayer) {
            return state;
          }

          // Allow the flow reducer to process any triggers that happen after moves.
          state = _extends({}, state, { ctx: _random2.attach(state.ctx) });
          state = _extends({}, state, { ctx: _events2.attach(state.ctx) });
          state = game.flow.processMove(state, action.payload);
          state = _events2.update(state);
          state = _extends({}, state, { ctx: _random2.update(state.ctx) });
          state = _extends({}, state, { ctx: Random.detach(state.ctx) });
          state = _extends({}, state, { ctx: Events.detach(state.ctx) });

          return state;
        }

      case RESTORE:
        {
          return action.state;
        }

      case RESET:
        {
          return initial;
        }

      case UNDO:
        {
          var _state = state,
              _undo = _state._undo,
              _redo = _state._redo;


          if (_undo.length < 2) {
            return state;
          }

          var last = _undo[_undo.length - 1];
          var restore = _undo[_undo.length - 2];

          // Only allow undoable moves to be undone.
          if (!game.flow.canUndoMove(state.G, state.ctx, last.moveType)) {
            return state;
          }

          return _extends({}, state, {
            G: restore.G,
            ctx: restore.ctx,
            _undo: _undo.slice(0, _undo.length - 1),
            _redo: [last].concat(toConsumableArray(_redo))
          });
        }

      case REDO:
        {
          var _state2 = state,
              _undo2 = _state2._undo,
              _redo2 = _state2._redo;


          if (_redo2.length == 0) {
            return state;
          }

          var first = _redo2[0];

          return _extends({}, state, {
            G: first.G,
            ctx: first.ctx,
            _undo: [].concat(toConsumableArray(_undo2), [first]),
            _redo: _redo2.slice(1)
          });
        }

      default:
        {
          return state;
        }
    }
  };
}

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var Koa$1 = require('koa');
var Router = require('koa-router');
var koaBody = require('koa-body');
var uuid = require('uuid/v4');
var cors = require('@koa/cors');
var Redux$1 = require('redux');

var createCredentials = function createCredentials() {
  return uuid();
};
var getGameMetadataKey = function getGameMetadataKey(gameID) {
  return gameID + ':metadata';
};
var getNewGameInstanceID = function getNewGameInstanceID() {
  return uuid();
};
var createGameMetadata = function createGameMetadata() {
  return {
    players: {}
  };
};

var isActionFromAuthenticPlayer = async function isActionFromAuthenticPlayer(_ref) {
  var action = _ref.action,
      db = _ref.db,
      gameID = _ref.gameID,
      playerID = _ref.playerID;

  var gameMetadata = await db.get(getGameMetadataKey(gameID));
  if (!gameMetadata) {
    return true;
  }

  if (!action.payload) {
    return true;
  }

  var hasCredentials = Object.keys(gameMetadata.players).some(function (key) {
    return !!(gameMetadata.players[key] && gameMetadata.players[key].credentials);
  });
  if (!hasCredentials) {
    return true;
  }

  if (!action.payload.credentials) {
    return false;
  }

  if (action.payload.credentials !== gameMetadata.players[playerID].credentials) {
    return false;
  }

  return true;
};

var createApiServer = function createApiServer(_ref2) {
  var db = _ref2.db,
      games = _ref2.games;

  var app = new Koa$1();
  var router = new Router();

  router.get('/games', async function (ctx) {
    ctx.body = games.map(function (game) {
      return game.name;
    });
  });

  router.post('/games/:name/create', koaBody(), async function (ctx) {
    var gameName = ctx.params.name;
    var numPlayers = parseInt(ctx.request.body.numPlayers);
    if (!numPlayers) {
      numPlayers = 2;
    }

    var gameMetadata = createGameMetadata();

    var game = games.find(function (g) {
      return g.name === gameName;
    });
    var reducer = CreateGameReducer({
      game: game,
      numPlayers: numPlayers
    });
    var store = Redux$1.createStore(reducer);
    var state = store.getState();

    for (var playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
      var credentials = createCredentials();
      gameMetadata.players[playerIndex] = { id: playerIndex, credentials: credentials };
    }

    var gameID = getNewGameInstanceID();
    var namespacedGameID = gameName + ':' + gameID;

    await db.set(getGameMetadataKey(namespacedGameID), gameMetadata);
    await db.set(namespacedGameID, state);

    ctx.body = {
      gameID: gameID
    };
  });

  router.post('/games/:name/:id/join', koaBody(), async function (ctx) {
    var gameName = ctx.params.name;
    var gameID = ctx.params.id;
    var playerID = ctx.request.body.playerID;
    var playerName = ctx.request.body.playerName;

    var namespacedGameID = gameName + ':' + gameID;
    var gameMetadata = await db.get(getGameMetadataKey(namespacedGameID));

    if (gameMetadata === null) {
      ctx.throw(404, 'Game not found');
    }

    gameMetadata.players[playerID].name = playerName;
    var playerCredentials = gameMetadata.players[playerID].credentials;

    await db.set(getGameMetadataKey(namespacedGameID), gameMetadata);

    ctx.body = {
      playerCredentials: playerCredentials
    };
  });

  app.use(cors());

  // If API_SECRET is set, then require that requests set an
  // api-secret header that is set to the same value.
  app.use(async function (ctx, next) {
    if (!!process.env.API_SECRET && ctx.request.headers['api-secret'] !== process.env.API_SECRET) {
      ctx.throw(403, 'Invalid API secret');
    }

    await next();
  });

  app.use(router.routes()).use(router.allowedMethods());

  return app;
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var Koa = require('koa');
var IO = require('koa-socket');
var Redux = require('redux');

var PING_TIMEOUT = 20 * 1e3;
var PING_INTERVAL = 10 * 1e3;

function Server(_ref) {
  var games = _ref.games,
      db = _ref.db,
      _clientInfo = _ref._clientInfo,
      _roomInfo = _ref._roomInfo;

  var app = new Koa();
  var io = new IO({
    ioOptions: {
      pingTimeout: PING_TIMEOUT,
      pingInterval: PING_INTERVAL
    }
  });
  app.context.io = io;
  io.attach(app);

  if (db === undefined) {
    db = DBFromEnv();
  }

  var api = createApiServer({ db: db, games: games });

  var clientInfo = _clientInfo || new Map();
  var roomInfo = _roomInfo || new Map();

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var game = _step.value;

      var nsp = app._io.of(game.name);

      nsp.on('connection', function (socket) {
        socket.on('action', async function (action, stateID, gameID, playerID) {
          var state = await db.get(gameID);

          if (state === undefined) {
            return { error: 'game not found' };
          }

          var reducer = CreateGameReducer({
            game: game,
            numPlayers: state.ctx.numPlayers
          });
          var store = Redux.createStore(reducer, state);

          var isActionAuthentic = await isActionFromAuthenticPlayer({
            action: action,
            db: db,
            gameID: gameID,
            playerID: playerID
          });
          if (!isActionAuthentic) {
            return { error: 'unauthorized action' };
          }

          // Check whether the player is allowed to make the move.
          if (action.type == MAKE_MOVE && !game.flow.canPlayerMakeMove(state.G, state.ctx, playerID)) {
            return;
          }

          // Check whether the player is allowed to call the event.
          if (action.type == GAME_EVENT && !game.flow.canPlayerCallEvent(state.G, state.ctx, playerID)) {
            return;
          }

          if (state._stateID == stateID) {
            // Update server's version of the store.
            store.dispatch(action);
            state = store.getState();

            // Get clients connected to this current game.
            var roomClients = roomInfo.get(gameID);
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = roomClients.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var client = _step2.value;

                var _clientInfo$get = clientInfo.get(client),
                    _playerID = _clientInfo$get.playerID;

                var ctx = Object.assign({}, state.ctx, { _random: undefined });
                var newState = Object.assign({}, state, {
                  G: game.playerView(state.G, ctx, _playerID),
                  ctx: ctx
                });

                if (client === socket.id) {
                  socket.emit('sync', gameID, newState);
                } else {
                  socket.to(client).emit('sync', gameID, newState);
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            await db.set(gameID, store.getState());
          }

          return;
        });

        socket.on('sync', async function (gameID, playerID, numPlayers) {
          socket.join(gameID);
          var reducer = CreateGameReducer({ game: game, numPlayers: numPlayers });
          var roomClients = roomInfo.get(gameID);
          if (roomClients === undefined) {
            roomClients = new Set();
            roomInfo.set(gameID, roomClients);
          }
          roomClients.add(socket.id);

          clientInfo.set(socket.id, { gameID: gameID, playerID: playerID });

          var state = await db.get(gameID);

          if (state === undefined) {
            var store = Redux.createStore(reducer);
            state = store.getState();
            await db.set(gameID, state);
          }

          var ctx = Object.assign({}, state.ctx, { _random: undefined });
          var newState = Object.assign({}, state, {
            G: game.playerView(state.G, ctx, playerID),
            ctx: ctx
          });

          socket.emit('sync', gameID, newState);

          return;
        });

        socket.on('disconnect', function () {
          if (clientInfo.has(socket.id)) {
            var _clientInfo$get2 = clientInfo.get(socket.id),
                gameID = _clientInfo$get2.gameID;

            roomInfo.get(gameID).delete(socket.id);
            clientInfo.delete(socket.id);
          }
        });
      });
    };

    for (var _iterator = games[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return {
    app: app,
    api: api,
    db: db,
    run: async function run(port, callback) {
      await db.connect();
      await api.listen(port + 1);
      await app.listen(port, callback);
    }
  };
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

exports.Server = Server;
exports.Mongo = Mongo;
exports.Firebase = Firebase;
